{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the EMR Containers Best Practices Guide. The primary goal of this project is to offer a set of best practices and templates to get started with Amazon EMR on EKS . We publish this guide on GitHub so we could iterate the content quickly, provide timely and effective recommendations for variety of concerns, and easily incorporate suggestions from the broader community. Amazon EMR on EKS Workshop \u00b6 If you are interested in step by step tutorials that leverage the best practices contained in this guide, please visit the Amazon EMR on EKS Workshop. Contributing \u00b6 We encourage you to contribute to these guides. If you have implemented a practice that has proven to be effective, please share it with us by opening an issue or a pull request. Similarly, if you discover an error or flaw in the guide, please submit a pull request to correct it.","title":"Introduction"},{"location":"#amazon-emr-on-eks-workshop","text":"If you are interested in step by step tutorials that leverage the best practices contained in this guide, please visit the Amazon EMR on EKS Workshop.","title":"Amazon EMR on EKS Workshop"},{"location":"#contributing","text":"We encourage you to contribute to these guides. If you have implemented a practice that has proven to be effective, please share it with us by opening an issue or a pull request. Similarly, if you discover an error or flaw in the guide, please submit a pull request to correct it.","title":"Contributing"},{"location":"best-practices-and-recommendations/eks-best-practices/","text":"EKS Best Practices and Recommendations \u00b6 Amazon EMR on EKS team has run scale tests on EKS cluster and has compiled a list of recommendations. The purpose of this document is to share our recommendations for running large scale EKS clusters supporting EMR on EKS. Amazon VPC CNI Best practices \u00b6 Recommendation 1: Improve IP Address Utilization \u00b6 EKS clusters can run out of IP addresses for pods when they reached between 400 and 500 nodes. With the default CNI settings, each node can request more IP addresses than is required. To ensure that you don\u2019t run out of IP addresses, there are two solutions: Set MINIMUM_IP_TARGET and WARM_IP_TARGET instead of the default setting of WARM_ENI_TARGET=1 . The values of these settings will depend on your instance type, expected pod density, and workload. More info about these CNI settings can be found here . The maximum number of IP addresses per node (and thus maximum number of pods per node) depends on instance type and can be looked up here . If you have found the right CNI settings as described above, the subnets created by eksctl still do not provide enough addresses (by default eksctl creates a \u201c/19\u201d subnet for each nodegroup, which contains ~8.1k addresses). You can configure CNI to take addresses from (larger) subnets that you create. For example, you could create a few \u201c/16\u201d subnets, which contain ~65k IP addresses per subnet. You should implement this option after you have configured the CNI settings as described in #1. To configure your pods to use IP addresses from larger manually-created subnets, use CNI custom networking (see below for more information): CNI custom networking By default, the CNI assigns the Pod\u2019s IP address from the worker node's primary elastic network interface's (ENI) security groups and subnet. If you don\u2019t have enough IP addresses in the worker node subnet, or prefer that the worker nodes and Pods reside in separate subnets to avoid IP address allocation conflicts between Pods and other resources in the VPC, you can use CNI custom networking . Enabling a custom network removes an available elastic network interface (and all of its available IP addresses for pods) from each worker node that uses it. The worker node's primary network interface is not used for pod placement when a custom network is enabled. If you want the CNI to assign IP addresses for Pods from a different subnet, you can set AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG environment variable to true . kubectl set env daemonset aws-node \\ -n kube-system AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG = true When AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true , the CNI will assign Pod IP address from a subnet defined in ENIConfig . The ENIConfig custom resource is used to define the subnet in which Pods will be scheduled. apiVersion : crd.k8s.amazonaws.com/v1alpha1 kind : ENIConfig metadata : name : us-west-2a spec : securityGroups : - sg-0dff111a1d11c1c11 subnet : subnet-011b111c1f11fdf11 You will need to create an ENIconfig custom resource for each subnet you want to use for Pod networking. The securityGroups field should have the ID of the security group attached to the worker nodes. The name field should be the name of the Availability Zone in your VPC. If you name your ENIConfig custom resources after each Availability Zone in your VPC, you can enable Kubernetes to automatically apply the corresponding ENIConfig for the worker node Availability Zone with the following command. kubectl set env daemonset aws-node \\ -n kube-system ENI_CONFIG_LABEL_DEF = failure-domain.beta.kubernetes.io/zone Note Upon creating the ENIconfig custom resources, you will need to create new worker nodes. The existing worker nodes and Pods will remain unaffected. Recommendation 2: Prevent EC2 VPC API throttling from AssignPrivateIpAddresses & AttachNetworkInterface \u00b6 Often EKS cluster scale-out time can increase because the CNI is being throttled by the EC2 VPC APIs. The following steps can be taken to prevent these issues: Use CNI version 1.8.0 or later as it reduces the calls to EC2 VPC APIs than earlier versions. Configure the MINIMUM_IP_TARGET and WARM_IP_TARGET parameters instead of the default parameter of WARM_ENI_TARGET=1 . Only those IP addresses that are necessary are requested from EC2. The values of these settings will depend on your instance type and expected pod density. More info about these settings here . Request an API limit increase on the EC2 VPC APIs that are getting throttled. This option should be considered only after steps 1 & 2 have been done. Other Recommendations for Amazon VPC CNI \u00b6 Plan for growth \u00b6 Size the subnets you will use for Pod networking for growth. If you have insufficient IP addresses available in the subnet that the CNI uses, your pods will not get an IP address. The pods will remain in the pending state until an IP address becomes available. This may impact application autoscaling and compromise its availability. Monitor IP address inventory \u00b6 You can monitor the IP addresses inventory of subnets using the CNI Metrics Helper , and set CloudWatch alarms to get notified if a subnet is running out of IP addresses. SNAT setting \u00b6 Source Network Address Translation (source-nat or SNAT) allows traffic from a private network to go out to the internet. Virtual machines launched on a private network can get to the internet by going through a gateway capable of performing SNAT. If your Pods with private IP address need to communicate with other private IP address spaces (for example, Direct Connect, VPC Peering or Transit VPC), then you should enable external SNAT in the CNI: kubectl set env daemonset \\ -n kube-system aws-node AWS_VPC_K8S_CNI_EXTERNALSNAT = true CoreDNS Best practices \u00b6 Prevent CoreDNS from being overwhelmed (UnknownHostException in spark jobs and other pods) \u00b6 CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can be a problem for workloads that do a lot of DNS lookups. One simple solution is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks. Monitor CoreDNS metrics \u00b6 CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can cause workloads to timeout with unknownHostException as spark-executors will do a lot of DNS lookups which registering themselves to spark-driver. One simple solution to fix this is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks. Cluster Autoscaler Best practices \u00b6 Increase cluster-autoscaler memory to avoid unnecessary exceptions \u00b6 Cluster-autoscaler can require a lot of memory to run because it stores a lot of information about the state of the cluster, such as data about every pod and every node. If the cluster-autoscaler has insufficient memory, it can lead to the cluster-autoscaler crashing. Ensure that you provide the cluster-autoscaler deployment more memory, e.g., 1Gi memory instead of the default 300Mi. Useful information about configuring the cluster-autoscaler for improved scalability and performance can be found here Avoid job failures when Cluster Autoscaler attempts scale-in \u00b6 Cluster Autoscaler will attempt scale-in action for any under utilized instance within your EKScluster. When scale-in action is performed, all pods from that instance is relocated to another node. This could cause disruption for critical workloads. For example, if driver pod is restarted, the entire job needs to restart. For this reason, we recommend using Kubernetes annotations on all critical pods (especially driver pods) and for cluster autoscaler deployment. Please see here for more info cluster-autoscaler.kubernetes.io/safe-to-evict=false Configure overprovisioning with Cluster Autoscaler for higher priority jobs \u00b6 If the required resources is not available in the cluster, pods go into pending state. Cluster Autoscaler uses this metric to scale out the cluster and this activity can be time consuming (several minutes) for higher priority jobs. In order to minimize time required for scaling, we recommend overprovisioning resources. You can launch pause pods(dummy workloads which sleeps until it receives SIGINT or SIGTERM) with negative priority to reserve EC2 capacity. Once the higher priority jobs are scheduled, these pause pods are preempted to make room for high priority pods which in turn scales out additional capacity as a buffer. You need to be aware that this is a trade-off as it adds slightly higher cost while minimizing scheduling latency. You can read more about over provisioning best practice here . EKS Control Plane Best practices \u00b6 API server overwhelmed \u00b6 System pods, workload pods, and external systems can make many calls to the Kubernetes API server. This can decrease performance and also increase EMR on EKS job failures. There are multiple ways to avoid API server availability issues including but not limited to: By default, the EKS API servers are automatically scaled to meet your workload demand. If you see increased latencies, please contact AWS via a support ticket and work with engineering team to resolve the issue. Consider reducing the scan interval of cluster-autoscaler from the 10 second default value. Each time the cluster-autoscaler runs, it makes many calls to the API server. However, this will result in the cluster scaling-out less frequently and in larger steps (and same with scaling back in when load is reduced). More information can be found about the cluster-autoscaler here . This is not recommended if you need jobs to start ASAP. If you are running your own deployment of fluentd, an increased load on the APIserver can be observed. Consider using fluent-bit instead which makes fewer calls to the API server. More info can be found here Monitor Control Plane Metrics \u00b6 Monitoring Kubernetes API metrics can give you insights into control plane performance and identify issues. An unhealthy control plane can compromise the availability of the workloads running inside the cluster. For example, poorly written controllers can overload the API servers, affecting your application's availability. Kubernetes exposes control plane metrics at the /metrics endpoint. You can view the metrics exposed using kubectl : kubectl get --raw /metrics These metrics are represented in a Prometheus text format . You can use Prometheus to collect and store these metrics. In May 2020, CloudWatch added support for monitoring Prometheus metrics in CloudWatch Container Insights. So you can also use Amazon CloudWatch to monitor the EKS control plane. You can follow the Tutorial for Adding a New Prometheus Scrape Target: Prometheus KPI Server Metrics to collect metrics and create CloudWatch dashboard to monitor your cluster\u2019s control plane. You can also find Kubernetes API server metrics here . For example, apiserver_request_duration_seconds can indicate how long API requests are taking to run. Consider monitoring these control plane metrics: API Server \u00b6 Metric Description apiserver_request_total Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code. apiserver_request_duration_seconds* Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope, and component. rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. apiserver_admission_controller_admission_duration_seconds Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host. etcd \u00b6 Metric Description etcd_request_duration_seconds Etcd request latency in seconds for each operation and object type. You can visualize and monitor these Kubernetes API server requests, latency and etcD metrics on Grafana via Grafana dashboard 12006 .","title":"EKS Best Practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#eks-best-practices-and-recommendations","text":"Amazon EMR on EKS team has run scale tests on EKS cluster and has compiled a list of recommendations. The purpose of this document is to share our recommendations for running large scale EKS clusters supporting EMR on EKS.","title":"EKS Best Practices and Recommendations"},{"location":"best-practices-and-recommendations/eks-best-practices/#amazon-vpc-cni-best-practices","text":"","title":"Amazon VPC CNI Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-1-improve-ip-address-utilization","text":"EKS clusters can run out of IP addresses for pods when they reached between 400 and 500 nodes. With the default CNI settings, each node can request more IP addresses than is required. To ensure that you don\u2019t run out of IP addresses, there are two solutions: Set MINIMUM_IP_TARGET and WARM_IP_TARGET instead of the default setting of WARM_ENI_TARGET=1 . The values of these settings will depend on your instance type, expected pod density, and workload. More info about these CNI settings can be found here . The maximum number of IP addresses per node (and thus maximum number of pods per node) depends on instance type and can be looked up here . If you have found the right CNI settings as described above, the subnets created by eksctl still do not provide enough addresses (by default eksctl creates a \u201c/19\u201d subnet for each nodegroup, which contains ~8.1k addresses). You can configure CNI to take addresses from (larger) subnets that you create. For example, you could create a few \u201c/16\u201d subnets, which contain ~65k IP addresses per subnet. You should implement this option after you have configured the CNI settings as described in #1. To configure your pods to use IP addresses from larger manually-created subnets, use CNI custom networking (see below for more information): CNI custom networking By default, the CNI assigns the Pod\u2019s IP address from the worker node's primary elastic network interface's (ENI) security groups and subnet. If you don\u2019t have enough IP addresses in the worker node subnet, or prefer that the worker nodes and Pods reside in separate subnets to avoid IP address allocation conflicts between Pods and other resources in the VPC, you can use CNI custom networking . Enabling a custom network removes an available elastic network interface (and all of its available IP addresses for pods) from each worker node that uses it. The worker node's primary network interface is not used for pod placement when a custom network is enabled. If you want the CNI to assign IP addresses for Pods from a different subnet, you can set AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG environment variable to true . kubectl set env daemonset aws-node \\ -n kube-system AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG = true When AWS_VPC_K8S_CNI_CUSTOM_NETWORK_CFG=true , the CNI will assign Pod IP address from a subnet defined in ENIConfig . The ENIConfig custom resource is used to define the subnet in which Pods will be scheduled. apiVersion : crd.k8s.amazonaws.com/v1alpha1 kind : ENIConfig metadata : name : us-west-2a spec : securityGroups : - sg-0dff111a1d11c1c11 subnet : subnet-011b111c1f11fdf11 You will need to create an ENIconfig custom resource for each subnet you want to use for Pod networking. The securityGroups field should have the ID of the security group attached to the worker nodes. The name field should be the name of the Availability Zone in your VPC. If you name your ENIConfig custom resources after each Availability Zone in your VPC, you can enable Kubernetes to automatically apply the corresponding ENIConfig for the worker node Availability Zone with the following command. kubectl set env daemonset aws-node \\ -n kube-system ENI_CONFIG_LABEL_DEF = failure-domain.beta.kubernetes.io/zone Note Upon creating the ENIconfig custom resources, you will need to create new worker nodes. The existing worker nodes and Pods will remain unaffected.","title":"Recommendation 1: Improve IP Address Utilization"},{"location":"best-practices-and-recommendations/eks-best-practices/#recommendation-2-prevent-ec2-vpc-api-throttling-from-assignprivateipaddresses-attachnetworkinterface","text":"Often EKS cluster scale-out time can increase because the CNI is being throttled by the EC2 VPC APIs. The following steps can be taken to prevent these issues: Use CNI version 1.8.0 or later as it reduces the calls to EC2 VPC APIs than earlier versions. Configure the MINIMUM_IP_TARGET and WARM_IP_TARGET parameters instead of the default parameter of WARM_ENI_TARGET=1 . Only those IP addresses that are necessary are requested from EC2. The values of these settings will depend on your instance type and expected pod density. More info about these settings here . Request an API limit increase on the EC2 VPC APIs that are getting throttled. This option should be considered only after steps 1 & 2 have been done.","title":"Recommendation 2: Prevent EC2 VPC API throttling from AssignPrivateIpAddresses &amp; AttachNetworkInterface"},{"location":"best-practices-and-recommendations/eks-best-practices/#other-recommendations-for-amazon-vpc-cni","text":"","title":"Other Recommendations for Amazon VPC CNI"},{"location":"best-practices-and-recommendations/eks-best-practices/#plan-for-growth","text":"Size the subnets you will use for Pod networking for growth. If you have insufficient IP addresses available in the subnet that the CNI uses, your pods will not get an IP address. The pods will remain in the pending state until an IP address becomes available. This may impact application autoscaling and compromise its availability.","title":"Plan for growth"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-ip-address-inventory","text":"You can monitor the IP addresses inventory of subnets using the CNI Metrics Helper , and set CloudWatch alarms to get notified if a subnet is running out of IP addresses.","title":"Monitor IP address inventory"},{"location":"best-practices-and-recommendations/eks-best-practices/#snat-setting","text":"Source Network Address Translation (source-nat or SNAT) allows traffic from a private network to go out to the internet. Virtual machines launched on a private network can get to the internet by going through a gateway capable of performing SNAT. If your Pods with private IP address need to communicate with other private IP address spaces (for example, Direct Connect, VPC Peering or Transit VPC), then you should enable external SNAT in the CNI: kubectl set env daemonset \\ -n kube-system aws-node AWS_VPC_K8S_CNI_EXTERNALSNAT = true","title":"SNAT setting"},{"location":"best-practices-and-recommendations/eks-best-practices/#coredns-best-practices","text":"","title":"CoreDNS Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#prevent-coredns-from-being-overwhelmed-unknownhostexception-in-spark-jobs-and-other-pods","text":"CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can be a problem for workloads that do a lot of DNS lookups. One simple solution is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.","title":"Prevent CoreDNS from being overwhelmed (UnknownHostException in spark jobs and other pods)"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-coredns-metrics","text":"CoreDNS is a deployment, which means it runs a fixed number of replicas and thus does not scale out with the cluster. This can cause workloads to timeout with unknownHostException as spark-executors will do a lot of DNS lookups which registering themselves to spark-driver. One simple solution to fix this is to install dns-autoscaler , which adjusts the number of replicas of the CoreDNS deployment as the cluster grows and shrinks.","title":"Monitor CoreDNS metrics"},{"location":"best-practices-and-recommendations/eks-best-practices/#cluster-autoscaler-best-practices","text":"","title":"Cluster Autoscaler Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#increase-cluster-autoscaler-memory-to-avoid-unnecessary-exceptions","text":"Cluster-autoscaler can require a lot of memory to run because it stores a lot of information about the state of the cluster, such as data about every pod and every node. If the cluster-autoscaler has insufficient memory, it can lead to the cluster-autoscaler crashing. Ensure that you provide the cluster-autoscaler deployment more memory, e.g., 1Gi memory instead of the default 300Mi. Useful information about configuring the cluster-autoscaler for improved scalability and performance can be found here","title":"Increase cluster-autoscaler memory to avoid unnecessary exceptions"},{"location":"best-practices-and-recommendations/eks-best-practices/#avoid-job-failures-when-cluster-autoscaler-attempts-scale-in","text":"Cluster Autoscaler will attempt scale-in action for any under utilized instance within your EKScluster. When scale-in action is performed, all pods from that instance is relocated to another node. This could cause disruption for critical workloads. For example, if driver pod is restarted, the entire job needs to restart. For this reason, we recommend using Kubernetes annotations on all critical pods (especially driver pods) and for cluster autoscaler deployment. Please see here for more info cluster-autoscaler.kubernetes.io/safe-to-evict=false","title":"Avoid job failures when Cluster Autoscaler attempts scale-in"},{"location":"best-practices-and-recommendations/eks-best-practices/#configure-overprovisioning-with-cluster-autoscaler-for-higher-priority-jobs","text":"If the required resources is not available in the cluster, pods go into pending state. Cluster Autoscaler uses this metric to scale out the cluster and this activity can be time consuming (several minutes) for higher priority jobs. In order to minimize time required for scaling, we recommend overprovisioning resources. You can launch pause pods(dummy workloads which sleeps until it receives SIGINT or SIGTERM) with negative priority to reserve EC2 capacity. Once the higher priority jobs are scheduled, these pause pods are preempted to make room for high priority pods which in turn scales out additional capacity as a buffer. You need to be aware that this is a trade-off as it adds slightly higher cost while minimizing scheduling latency. You can read more about over provisioning best practice here .","title":"Configure overprovisioning with Cluster Autoscaler for higher priority jobs"},{"location":"best-practices-and-recommendations/eks-best-practices/#eks-control-plane-best-practices","text":"","title":"EKS Control Plane Best practices"},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server-overwhelmed","text":"System pods, workload pods, and external systems can make many calls to the Kubernetes API server. This can decrease performance and also increase EMR on EKS job failures. There are multiple ways to avoid API server availability issues including but not limited to: By default, the EKS API servers are automatically scaled to meet your workload demand. If you see increased latencies, please contact AWS via a support ticket and work with engineering team to resolve the issue. Consider reducing the scan interval of cluster-autoscaler from the 10 second default value. Each time the cluster-autoscaler runs, it makes many calls to the API server. However, this will result in the cluster scaling-out less frequently and in larger steps (and same with scaling back in when load is reduced). More information can be found about the cluster-autoscaler here . This is not recommended if you need jobs to start ASAP. If you are running your own deployment of fluentd, an increased load on the APIserver can be observed. Consider using fluent-bit instead which makes fewer calls to the API server. More info can be found here","title":"API server overwhelmed"},{"location":"best-practices-and-recommendations/eks-best-practices/#monitor-control-plane-metrics","text":"Monitoring Kubernetes API metrics can give you insights into control plane performance and identify issues. An unhealthy control plane can compromise the availability of the workloads running inside the cluster. For example, poorly written controllers can overload the API servers, affecting your application's availability. Kubernetes exposes control plane metrics at the /metrics endpoint. You can view the metrics exposed using kubectl : kubectl get --raw /metrics These metrics are represented in a Prometheus text format . You can use Prometheus to collect and store these metrics. In May 2020, CloudWatch added support for monitoring Prometheus metrics in CloudWatch Container Insights. So you can also use Amazon CloudWatch to monitor the EKS control plane. You can follow the Tutorial for Adding a New Prometheus Scrape Target: Prometheus KPI Server Metrics to collect metrics and create CloudWatch dashboard to monitor your cluster\u2019s control plane. You can also find Kubernetes API server metrics here . For example, apiserver_request_duration_seconds can indicate how long API requests are taking to run. Consider monitoring these control plane metrics:","title":"Monitor Control Plane Metrics"},{"location":"best-practices-and-recommendations/eks-best-practices/#api-server","text":"Metric Description apiserver_request_total Counter of apiserver requests broken out for each verb, dry run value, group, version, resource, scope, component, client, and HTTP response contentType and code. apiserver_request_duration_seconds* Response latency distribution in seconds for each verb, dry run value, group, version, resource, subresource, scope, and component. rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. apiserver_admission_controller_admission_duration_seconds Admission controller latency histogram in seconds, identified by name and broken out for each operation and API resource and type (validate or admit). rest_client_request_duration_seconds Request latency in seconds. Broken down by verb and URL. rest_client_requests_total Number of HTTP requests, partitioned by status code, method, and host.","title":"API Server"},{"location":"best-practices-and-recommendations/eks-best-practices/#etcd","text":"Metric Description etcd_request_duration_seconds Etcd request latency in seconds for each operation and object type. You can visualize and monitor these Kubernetes API server requests, latency and etcD metrics on Grafana via Grafana dashboard 12006 .","title":"etcd"},{"location":"debugging/docs/","text":"","title":"Index"},{"location":"debugging/docs/change-log-level/","text":"Change Log level for Spark application on EMR on EKS \u00b6 To obtain more detail about their application or job submission, Spark application developers can change the log level of their job to different levels depending on their requirements. Spark uses apache log4j for logging. Change log level to DEBUG \u00b6 Using EMR classification \u00b6 Log level of spark applications can be changed using the EMR spark-log4j configuration classification. Request pi.py used in the below request payload is from spark examples spark-log4j classification can be used to configure values in log4j.properties cat > Spark-Python-in-s3-debug-log.json << EOF { \"name\": \"spark-python-in-s3-debug-log-classification\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"spark-log4j\", \"properties\": { \"log4j.rootCategory\":\"DEBUG, console\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json The above request will print DEBUG logs in the spark driver and executor containers. The generated logs will be pushed to S3 and AWS Cloudwatch logs as configured in the request. Custom log4j properties \u00b6 Download log4j properties from here . Edit log4j.properties with log level as required. Save the edited log4j.properties in a mounted volume. In this example log4j.properties is placed in a s3 bucket that is mapped to a FSx for Lustre filesystem . Request pi.py used in the below request payload is from spark examples cat > Spark - Python - in - s3 - debug - log . json << EOF { \"name\" : \"spark-python-in-s3-debug-log\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - s3 - debug - log . json Configurations of interest: Below configuration enables spark driver and executor to pickup the log4j configuration file from /var/data/ folder mounted to the driver and executor containers. For guide to mount FSx for Lustre to driver and executor containers - refer to EMR Containers integration with FSx for Lustre \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" ,","title":"Change Log Level"},{"location":"debugging/docs/change-log-level/#change-log-level-for-spark-application-on-emr-on-eks","text":"To obtain more detail about their application or job submission, Spark application developers can change the log level of their job to different levels depending on their requirements. Spark uses apache log4j for logging.","title":"Change Log level for Spark application on EMR on EKS"},{"location":"debugging/docs/change-log-level/#change-log-level-to-debug","text":"","title":"Change log level to DEBUG"},{"location":"debugging/docs/change-log-level/#using-emr-classification","text":"Log level of spark applications can be changed using the EMR spark-log4j configuration classification. Request pi.py used in the below request payload is from spark examples spark-log4j classification can be used to configure values in log4j.properties cat > Spark-Python-in-s3-debug-log.json << EOF { \"name\": \"spark-python-in-s3-debug-log-classification\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"spark-log4j\", \"properties\": { \"log4j.rootCategory\":\"DEBUG, console\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-debug-log.json The above request will print DEBUG logs in the spark driver and executor containers. The generated logs will be pushed to S3 and AWS Cloudwatch logs as configured in the request.","title":"Using EMR classification"},{"location":"debugging/docs/change-log-level/#custom-log4j-properties","text":"Download log4j properties from here . Edit log4j.properties with log level as required. Save the edited log4j.properties in a mounted volume. In this example log4j.properties is placed in a s3 bucket that is mapped to a FSx for Lustre filesystem . Request pi.py used in the below request payload is from spark examples cat > Spark - Python - in - s3 - debug - log . json << EOF { \"name\" : \"spark-python-in-s3-debug-log\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - s3 - debug - log . json Configurations of interest: Below configuration enables spark driver and executor to pickup the log4j configuration file from /var/data/ folder mounted to the driver and executor containers. For guide to mount FSx for Lustre to driver and executor containers - refer to EMR Containers integration with FSx for Lustre \"spark.driver.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" , \"spark.executor.extraJavaOptions\" : \"-Dlog4j.configuration=file:///var/data/log4j-debug.properties\" ,","title":"Custom log4j properties"},{"location":"metastore-integrations/docs/","text":"","title":"Index"},{"location":"metastore-integrations/docs/aws-glue/","text":"EMR Containers integration with AWS Glue \u00b6 AWS Glue catalog in same account as EKS \u00b6 In the below example a Spark application will be configured to use AWS Glue data catalog as the hive metastore. gluequery.py cat > gluequery . py << EOF from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . appName ( \"Python Spark SQL Hive integration example\" ) \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"CREATE EXTERNAL TABLE `sparkemrnyc`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/trip-data.parquet/'\" ) spark . sql ( \"SELECT count(*) FROM sparkemrnyc\" ) . show () spark . stop () EOF LOCATION 's3://<s3 prefix>/trip-data.parquet/' Configure the above property to point to the S3 location containing the data. Request cat > Spark-Python-in-s3-awsglue-log.json << EOF { \"name\": \"spark-python-in-s3-awsglue-log\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-log.json Output from driver logs - Displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+ AWS Glue catalog in different account \u00b6 The Spark application is submitted to EMR Virtual cluster in Account A and is configured to connect to AWS Glue catalog in Account B. The IAM policy attached to the job execution role (\"executionRoleArn\": \"<execution-role-arn>\") is in Account A { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"glue:*\" ], \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } IAM policy attached to the AWS Glue catalog in Account B { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"<execution-role-arn>\" }, \"Action\" : \"glue:*\" , \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } Request cat > Spark-Python-in-s3-awsglue-crossaccount.json << EOF { \"name\": \"spark-python-in-s3-awsglue-crossaccount\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-crossaccount.json Configuration of interest To specify the accountID where the AWS Glue catalog is defined reference the following: Spark-Glue integration \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", Output from driver logs - displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+ Sync Hudi table with AWS Glue catalog \u00b6 In this example, a Spark application will be configured to use AWS Glue data catalog as the hive metastore. Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Glue catalog via the Hive Metastore Service (HMS) in hive sync mode. This example runs a Hudi ETL job with EMR on EKS, and interact with AWS Glue metaStore to create a Hudi table. It provides you the native and serverless capabilities to manage your technical metadata. Also you can query Hudi tables in Athena straigt away after the ETL job, which provides your end user an easy data access and shortens the time to insight. HudiEMRonEKS.py cat > HudiEMRonEKS . py << EOF import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) EOF NOTE: configure the warehouse dir property to point to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environament vairable. .config ( \"spark.sql.warehouse.dir\" , sys.argv [ 1 ] + \"/warehouse/\" ) Request export S3BUCKET = YOUR_S3_BUCKET_NAME aws emr - containers start - job - run \\ -- virtual - cluster - id $ VIRTUAL_CLUSTER_ID \\ -- name hudi - test1 \\ -- execution - role - arn $ EMR_ROLE_ARN \\ -- release - label emr - 6.3 . 0 - latest \\ -- job - driver '{ \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\" , \"entryPointArguments\" :[ \"s3://'$S3BUCKET'\" ], \"sparkSubmitParameters\" : \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\" }} ' \\ --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.serializer\" : \"org.apache.spark.serializer.KryoSerializer\" , \"spark.sql.hive.convertMetastoreParquet\" : \"false\" , \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" }} ], \"monitoringConfiguration\" : { \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\" }}} ' NOTE: To get a correct verison of hudi library, we directly download the jar from the maven repository with the synctax of \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar . Starting from EMR 6.5, the Hudi-spark3-bundle library will be included in EMR docker images.","title":"AWS Glue"},{"location":"metastore-integrations/docs/aws-glue/#emr-containers-integration-with-aws-glue","text":"","title":"EMR Containers integration with AWS Glue"},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-same-account-as-eks","text":"In the below example a Spark application will be configured to use AWS Glue data catalog as the hive metastore. gluequery.py cat > gluequery . py << EOF from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . appName ( \"Python Spark SQL Hive integration example\" ) \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"CREATE EXTERNAL TABLE `sparkemrnyc`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/trip-data.parquet/'\" ) spark . sql ( \"SELECT count(*) FROM sparkemrnyc\" ) . show () spark . stop () EOF LOCATION 's3://<s3 prefix>/trip-data.parquet/' Configure the above property to point to the S3 location containing the data. Request cat > Spark-Python-in-s3-awsglue-log.json << EOF { \"name\": \"spark-python-in-s3-awsglue-log\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=3 --conf spark.executor.memory=8G --conf spark.driver.memory=6G --conf spark.executor.cores=3\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-log.json Output from driver logs - Displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+","title":"AWS Glue catalog in same account as EKS"},{"location":"metastore-integrations/docs/aws-glue/#aws-glue-catalog-in-different-account","text":"The Spark application is submitted to EMR Virtual cluster in Account A and is configured to connect to AWS Glue catalog in Account B. The IAM policy attached to the job execution role (\"executionRoleArn\": \"<execution-role-arn>\") is in Account A { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"glue:*\" ], \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } IAM policy attached to the AWS Glue catalog in Account B { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Principal\" : { \"AWS\" : \"<execution-role-arn>\" }, \"Action\" : \"glue:*\" , \"Resource\" : [ \"arn:aws:glue:<region>:<account>:catalog\" , \"arn:aws:glue:<region>:<account>:database/default\" , \"arn:aws:glue:<region>:<account>:table/default/sparkemrnyc\" ] } ] } Request cat > Spark-Python-in-s3-awsglue-crossaccount.json << EOF { \"name\": \"spark-python-in-s3-awsglue-crossaccount\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/gluequery.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.hadoop.hive.metastore.client.factory.class\":\"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\", \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-awsglue-crossaccount.json Configuration of interest To specify the accountID where the AWS Glue catalog is defined reference the following: Spark-Glue integration \"spark.hadoop.hive.metastore.glue.catalogid\":\"<account B>\", Output from driver logs - displays the number of rows. +----------+ | count(1)| +----------+ |2716504499| +----------+","title":"AWS Glue catalog in different account"},{"location":"metastore-integrations/docs/aws-glue/#sync-hudi-table-with-aws-glue-catalog","text":"In this example, a Spark application will be configured to use AWS Glue data catalog as the hive metastore. Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Glue catalog via the Hive Metastore Service (HMS) in hive sync mode. This example runs a Hudi ETL job with EMR on EKS, and interact with AWS Glue metaStore to create a Hudi table. It provides you the native and serverless capabilities to manage your technical metadata. Also you can query Hudi tables in Athena straigt away after the ETL job, which provides your end user an easy data access and shortens the time to insight. HudiEMRonEKS.py cat > HudiEMRonEKS . py << EOF import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) EOF NOTE: configure the warehouse dir property to point to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environament vairable. .config ( \"spark.sql.warehouse.dir\" , sys.argv [ 1 ] + \"/warehouse/\" ) Request export S3BUCKET = YOUR_S3_BUCKET_NAME aws emr - containers start - job - run \\ -- virtual - cluster - id $ VIRTUAL_CLUSTER_ID \\ -- name hudi - test1 \\ -- execution - role - arn $ EMR_ROLE_ARN \\ -- release - label emr - 6.3 . 0 - latest \\ -- job - driver '{ \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://'$S3BUCKET'/app_code/job/HudiEMRonEKS.py\" , \"entryPointArguments\" :[ \"s3://'$S3BUCKET'\" ], \"sparkSubmitParameters\" : \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\" }} ' \\ --configuration-overrides ' { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.serializer\" : \"org.apache.spark.serializer.KryoSerializer\" , \"spark.sql.hive.convertMetastoreParquet\" : \"false\" , \"spark.hadoop.hive.metastore.client.factory.class\" : \"com.amazonaws.glue.catalog.metastore.AWSGlueDataCatalogHiveClientFactory\" }} ], \"monitoringConfiguration\" : { \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://'$S3BUCKET'/elasticmapreduce/emr-containers\" }}} ' NOTE: To get a correct verison of hudi library, we directly download the jar from the maven repository with the synctax of \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar . Starting from EMR 6.5, the Hudi-spark3-bundle library will be included in EMR docker images.","title":"Sync Hudi table with AWS Glue catalog"},{"location":"metastore-integrations/docs/hive-metastore/","text":"EMR Containers integration with Hive Metastore \u00b6 For more details, check out the github repository , which includes CDK/CFN templates that help you to get started quickly. 1-Hive metastore Database through JDBC \u00b6 In this example, a Spark application is configured to connect to a Hive Metastore database provisioned with Amazon RDS Aurora MySql via a JDBC connection. The Amazon RDS and EKS cluster should be in same VPC or else the Spark job will not be able to connect to RDS. You directly pass in the JDBC credentials at the job/application level, which is a simple and quick solution to make a connection to the HMS. However, it is not recommended in a production environment. From the security perspective, the password management could be a risk since the JDBC credentials will appear in all of your job logs. Also engineers may be required to hold the password when it is not necessary. Request: cat > Spark-Python-in-s3-hms-jdbc.json << EOF { \"name\": \"spark-python-in-s3-hms-jdbc\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/hivejdbc.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL=<JDBC-Connection-string> --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-jdbc.json In this example we are connecting to mysql db, so mariadb-connector-java.jar needs to be passed with --jars option. If you are using postgres, Oracle or any other database, the appropriate connector jar needs to be included. Configuration of interest: --jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL**=<JDBC-Connection-string> hivejdbc.py from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE `ehmsdb`.`sparkemrnyc5`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT count(*) FROM ehmsdb.sparkemrnyc5 \" ) . show () spark . stop () The above job lists databases from a remote RDS Hive Metastore, creates a new table and then queries it. 2-Hive metastore thrift service through thrift:// protocol \u00b6 In this example, the spark application is configured to connect to an external Hive metastore thrift server. The thrift server is running on EMR on EC2's master node and AWS RDS Aurora is used as database for the Hive metastore. Running an EMR on EC2 cluster as a thrift server, simplify the application configuration and setup. You can start quickly with reduced engineering effort. However, your maintenance overhead may increase, since you will be monitoring two types of clusters, i.e. EMR on EC2 and EMR on EKS. thriftscript.py: hive.metastore.uris config needs to be set to read from external Hive metastore. The URI format looks like this: thrift://EMR_ON_EC2_MASTER_NODE_DNS_NAME:9083 from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . config ( \"hive.metastore.uris\" , \"<hive metastore thrift uri>\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE ehmsdb.`sparkemrnyc2`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT * FROM ehmsdb.sparkemrnyc2\" ) . show () spark . stop () Request: The below job lists databases from remote Hive Metastore, creates a new table and then queries it. cat > Spark-Python-in-s3-hms-thrift.json << EOF { \"name\": \"spark-python-in-s3-hms-thrift\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/thriftscript.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-thrift.json 3-Connect Hive metastore via thrift service hosted on EKS \u00b6 In this example, our Spark application connects to a standalone Hive metastore service (HMS) running in EKS. Running the standalone HMS in EKS unifies your analytics applications with other business critical apps in a single platform. It simplifies your solution architecture and infrastructure design. The helm chart solution includes autoscaling feature, so your EKS cluster can automatically expand or shrink when the HMS request volume changes. Also it follows the security best practice to manage JDBC credentials via AWS Secrets Manager. However, you will need a combination of analytics and k8s skills to maintain this solution. To install the HMS helm chart , simply replace the environment variables in values.yaml, then manually helm install via the command below. Otherwise, deploy the HMS via a CDK/CFN template with a security best practice. Check out the CDK project for more details. cd hive-emr-on-eks/hive-metastore-chart sed -i '' -e 's/{RDS_JDBC_URL}/\"jdbc:mysql:\\/\\/' $YOUR_HOST_NAME ':3306\\/' $YOUR_DB_NAME '?createDatabaseIfNotExist=true\"/g' values.yaml sed -i '' -e 's/{RDS_USERNAME}/' $YOUR_USER_NAME '/g' values.yaml sed -i '' -e 's/{RDS_PASSWORD}/' $YOUR_PASSWORD '/g' values.yaml sed -i '' -e 's/{S3BUCKET}/s3:\\/\\/' $YOUR_S3BUCKET '/g' values.yaml helm repo add hive-metastore https://aws-samples.github.io/hive-metastore-chart helm install hive hive-metastore/hive-metastore -f values.yaml --namespace = emr --debug hivethrift_eks.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . config ( \"hive.metastore.uris\" , \"thrift://\" + environ [ 'HIVE_METASTORE_SERVICE_HOST' ] + \":9083\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview3\" ) spark . sql ( \"CREATE EXTERNAL TABLE IF NOT EXISTS `demo`.`amazonreview3`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview3\" ) . show () spark . stop () An environment variable HIVE_METASTORE_SERVICE_HOST appears in your Spark application pods automatically, once the standalone HMS is up running in EKS. You can directly set the hive.metastore.uris to thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\" . Can set the spark.sql.warehouse.dir property to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environment variable. Request: #!/bin/bash aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name spark-hive-via-thrift \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.2.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}' 4-Run thrift service as a sidecar in Spark Driver's pod \u00b6 This advanced solution runs the standalone HMS thrift service inside a Spark driver as a sidecar. It means each Spark job will have its dedicated thrift server. The benefit of the design is HMS is no long a single point of failure, since each Spark application has its own HMS. Also it is no long a long running service, i.e. it spins up when your Spark job starts, then terminates when your job is done. The sidecar follows the security best practice via leveraging Secrets Manager to extract JDBC crednetials. However, the maintenance of the sidecar increases because you now need to manage the hms sidecar, custom configmaps and sidecar pod templates. Also this solution requires combination skills of analytics and k8s. The CDK/CFN template is available to simplify the installation against a new EKS cluster. If you have an existing EKS cluster, the prerequisite details can be found in the github repository sidecar_hivethrift_eks.py: import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview4\" ) spark . sql ( \"CREATE EXTERNAL TABLE `demo`.`amazonreview4`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview4\" ) . show () spark . stop () Request: Now that the HMS is running inside your Spark driver, it share common attributes such as the network config, the spark.hive.metastore.uris can set to \"thrift://localhost:9083\". Don't forget to assign the sidecar pod template to the Spark Driver like this \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\" For more details, check out the github repo #!/bin/bash # test HMS sidecar on EKS aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name sidecar-hms \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\" } } ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}' 5-Hudi + Remote Hive metastore integration \u00b6 Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Hive metastore in HMS sync mode, with this setting 'hoodie.datasource.hive_sync.mode': 'hms' . This example runs a Hudi job with EMR on EKS, and interact with a remote RDS hive metastore to create a Hudi table. As a serverless option, it can interact with AWS Glue catalog. check out the AWS Glue section for more details. HudiEMRonEKS.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) print ( \"After {} \" . format ( spark . catalog . listTables ())) Request: The latest Hudi-spark3-bundle library is needed to support the new HMS hive sync functionality. In the following sample script, it is downloaded from maven repository when submitting a job with EMR 6.3. Starting from EMR 6.5, you don't need the --jars setting anymore, because EMR 6.5+ includes the Hudi-spark3-bundle library. aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name hudi-test1 \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/HudiEMRonEKS.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\", \"spark.sql.hive.convertMetastoreParquet\": \"false\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\" }} ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"Hive Metastore"},{"location":"metastore-integrations/docs/hive-metastore/#emr-containers-integration-with-hive-metastore","text":"For more details, check out the github repository , which includes CDK/CFN templates that help you to get started quickly.","title":"EMR Containers integration with Hive Metastore"},{"location":"metastore-integrations/docs/hive-metastore/#1-hive-metastore-database-through-jdbc","text":"In this example, a Spark application is configured to connect to a Hive Metastore database provisioned with Amazon RDS Aurora MySql via a JDBC connection. The Amazon RDS and EKS cluster should be in same VPC or else the Spark job will not be able to connect to RDS. You directly pass in the JDBC credentials at the job/application level, which is a simple and quick solution to make a connection to the HMS. However, it is not recommended in a production environment. From the security perspective, the password management could be a risk since the JDBC credentials will appear in all of your job logs. Also engineers may be required to hold the password when it is not necessary. Request: cat > Spark-Python-in-s3-hms-jdbc.json << EOF { \"name\": \"spark-python-in-s3-hms-jdbc\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/hivejdbc.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL=<JDBC-Connection-string> --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-jdbc.json In this example we are connecting to mysql db, so mariadb-connector-java.jar needs to be passed with --jars option. If you are using postgres, Oracle or any other database, the appropriate connector jar needs to be included. Configuration of interest: --jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.hadoop.javax.jdo.option.ConnectionDriverName=org.mariadb.jdbc.Driver --conf spark.hadoop.javax.jdo.option.ConnectionUserName=<connection-user-name> --conf spark.hadoop.javax.jdo.option.ConnectionPassword=<connection-password> --conf spark.hadoop.javax.jdo.option.ConnectionURL**=<JDBC-Connection-string> hivejdbc.py from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE `ehmsdb`.`sparkemrnyc5`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT count(*) FROM ehmsdb.sparkemrnyc5 \" ) . show () spark . stop () The above job lists databases from a remote RDS Hive Metastore, creates a new table and then queries it.","title":"1-Hive metastore Database through JDBC"},{"location":"metastore-integrations/docs/hive-metastore/#2-hive-metastore-thrift-service-through-thrift-protocol","text":"In this example, the spark application is configured to connect to an external Hive metastore thrift server. The thrift server is running on EMR on EC2's master node and AWS RDS Aurora is used as database for the Hive metastore. Running an EMR on EC2 cluster as a thrift server, simplify the application configuration and setup. You can start quickly with reduced engineering effort. However, your maintenance overhead may increase, since you will be monitoring two types of clusters, i.e. EMR on EC2 and EMR on EKS. thriftscript.py: hive.metastore.uris config needs to be set to read from external Hive metastore. The URI format looks like this: thrift://EMR_ON_EC2_MASTER_NODE_DNS_NAME:9083 from os.path import expanduser , join , abspath from pyspark.sql import SparkSession from pyspark.sql import Row # warehouse_location points to the default location for managed databases and tables warehouse_location = abspath ( 'spark-warehouse' ) spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , warehouse_location ) \\ . config ( \"hive.metastore.uris\" , \"<hive metastore thrift uri>\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE EXTERNAL TABLE ehmsdb.`sparkemrnyc2`( `dispatching_base_num` string, `pickup_datetime` string, `dropoff_datetime` string, `pulocationid` bigint, `dolocationid` bigint, `sr_flag` bigint) STORED AS PARQUET LOCATION 's3://<s3 prefix>/nyctaxi_parquet/'\" ) spark . sql ( \"SELECT * FROM ehmsdb.sparkemrnyc2\" ) . show () spark . stop () Request: The below job lists databases from remote Hive Metastore, creates a new table and then queries it. cat > Spark-Python-in-s3-hms-thrift.json << EOF { \"name\": \"spark-python-in-s3-hms-thrift\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/thriftscript.py\", \"sparkSubmitParameters\": \"--jars s3://<s3 prefix>/mariadb-connector-java.jar --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-hms-thrift.json","title":"2-Hive metastore thrift service through thrift:// protocol"},{"location":"metastore-integrations/docs/hive-metastore/#3-connect-hive-metastore-via-thrift-service-hosted-on-eks","text":"In this example, our Spark application connects to a standalone Hive metastore service (HMS) running in EKS. Running the standalone HMS in EKS unifies your analytics applications with other business critical apps in a single platform. It simplifies your solution architecture and infrastructure design. The helm chart solution includes autoscaling feature, so your EKS cluster can automatically expand or shrink when the HMS request volume changes. Also it follows the security best practice to manage JDBC credentials via AWS Secrets Manager. However, you will need a combination of analytics and k8s skills to maintain this solution. To install the HMS helm chart , simply replace the environment variables in values.yaml, then manually helm install via the command below. Otherwise, deploy the HMS via a CDK/CFN template with a security best practice. Check out the CDK project for more details. cd hive-emr-on-eks/hive-metastore-chart sed -i '' -e 's/{RDS_JDBC_URL}/\"jdbc:mysql:\\/\\/' $YOUR_HOST_NAME ':3306\\/' $YOUR_DB_NAME '?createDatabaseIfNotExist=true\"/g' values.yaml sed -i '' -e 's/{RDS_USERNAME}/' $YOUR_USER_NAME '/g' values.yaml sed -i '' -e 's/{RDS_PASSWORD}/' $YOUR_PASSWORD '/g' values.yaml sed -i '' -e 's/{S3BUCKET}/s3:\\/\\/' $YOUR_S3BUCKET '/g' values.yaml helm repo add hive-metastore https://aws-samples.github.io/hive-metastore-chart helm install hive hive-metastore/hive-metastore -f values.yaml --namespace = emr --debug hivethrift_eks.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . config ( \"hive.metastore.uris\" , \"thrift://\" + environ [ 'HIVE_METASTORE_SERVICE_HOST' ] + \":9083\" ) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview3\" ) spark . sql ( \"CREATE EXTERNAL TABLE IF NOT EXISTS `demo`.`amazonreview3`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview3\" ) . show () spark . stop () An environment variable HIVE_METASTORE_SERVICE_HOST appears in your Spark application pods automatically, once the standalone HMS is up running in EKS. You can directly set the hive.metastore.uris to thrift://\"+environ['HIVE_METASTORE_SERVICE_HOST']+\":9083\" . Can set the spark.sql.warehouse.dir property to a S3 location as your hive warehouse storage. The s3 location can be dynamic, which is based on an argument passed in or an environment variable. Request: #!/bin/bash aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name spark-hive-via-thrift \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.2.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"3-Connect Hive metastore via thrift service hosted on EKS"},{"location":"metastore-integrations/docs/hive-metastore/#4-run-thrift-service-as-a-sidecar-in-spark-drivers-pod","text":"This advanced solution runs the standalone HMS thrift service inside a Spark driver as a sidecar. It means each Spark job will have its dedicated thrift server. The benefit of the design is HMS is no long a single point of failure, since each Spark application has its own HMS. Also it is no long a long running service, i.e. it spins up when your Spark job starts, then terminates when your job is done. The sidecar follows the security best practice via leveraging Secrets Manager to extract JDBC crednetials. However, the maintenance of the sidecar increases because you now need to manage the hms sidecar, custom configmaps and sidecar pod templates. Also this solution requires combination skills of analytics and k8s. The CDK/CFN template is available to simplify the installation against a new EKS cluster. If you have an existing EKS cluster, the prerequisite details can be found in the github repository sidecar_hivethrift_eks.py: import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , environ [ 'warehouse_location' ]) \\ . enableHiveSupport () \\ . getOrCreate () spark . sql ( \"SHOW DATABASES\" ) . show () spark . sql ( \"CREATE DATABASE IF NOT EXISTS `demo`\" ) spark . sql ( \"DROP TABLE IF EXISTS demo.amazonreview4\" ) spark . sql ( \"CREATE EXTERNAL TABLE `demo`.`amazonreview4`( `marketplace` string,`customer_id`string,`review_id` string,`product_id` string,`product_parent` string,`product_title` string,`star_rating` integer,`helpful_votes` integer,`total_votes` integer,`vine` string,`verified_purchase` string,`review_headline` string,`review_body` string,`review_date` date,`year` integer) STORED AS PARQUET LOCATION '\" + sys . argv [ 1 ] + \"/app_code/data/toy/'\" ) spark . sql ( \"SELECT coount(*) FROM demo.amazonreview4\" ) . show () spark . stop () Request: Now that the HMS is running inside your Spark driver, it share common attributes such as the network config, the spark.hive.metastore.uris can set to \"thrift://localhost:9083\". Don't forget to assign the sidecar pod template to the Spark Driver like this \"spark.kubernetes.driver.podTemplateFile\": \"s3://'$S3BUCKET'/app_code/job/sidecar_hms_pod_template.yaml\" For more details, check out the github repo #!/bin/bash # test HMS sidecar on EKS aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name sidecar-hms \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hivethrift_eks.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--conf spark.driver.cores=1 --conf spark.executor.memory=4G --conf spark.driver.memory=1G --conf spark.executor.cores=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\" } } ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"4-Run thrift service as a sidecar in Spark Driver's pod"},{"location":"metastore-integrations/docs/hive-metastore/#5-hudi-remote-hive-metastore-integration","text":"Starting from Hudi 0.9.0, we can synchronize Hudi table's latest schema to Hive metastore in HMS sync mode, with this setting 'hoodie.datasource.hive_sync.mode': 'hms' . This example runs a Hudi job with EMR on EKS, and interact with a remote RDS hive metastore to create a Hudi table. As a serverless option, it can interact with AWS Glue catalog. check out the AWS Glue section for more details. HudiEMRonEKS.py from os import environ import sys from pyspark.sql import SparkSession spark = SparkSession \\ . builder \\ . config ( \"spark.sql.warehouse.dir\" , sys . argv [ 1 ] + \"/warehouse/\" ) \\ . enableHiveSupport () \\ . getOrCreate () # Create a DataFrame inputDF = spark . createDataFrame ( [ ( \"100\" , \"2015-01-01\" , \"2015-01-01T13:51:39.340396Z\" ), ( \"101\" , \"2015-01-01\" , \"2015-01-01T12:14:58.597216Z\" ), ( \"102\" , \"2015-01-01\" , \"2015-01-01T13:51:40.417052Z\" ), ( \"103\" , \"2015-01-01\" , \"2015-01-01T13:51:40.519832Z\" ), ( \"104\" , \"2015-01-02\" , \"2015-01-01T12:15:00.512679Z\" ), ( \"105\" , \"2015-01-02\" , \"2015-01-01T13:51:42.248818Z\" ), ], [ \"id\" , \"creation_date\" , \"last_update_time\" ] ) # Specify common DataSourceWriteOptions in the single hudiOptions variable test_tableName = \"hudi_tbl\" hudiOptions = { 'hoodie.table.name' : test_tableName , 'hoodie.datasource.write.recordkey.field' : 'id' , 'hoodie.datasource.write.partitionpath.field' : 'creation_date' , 'hoodie.datasource.write.precombine.field' : 'last_update_time' , 'hoodie.datasource.hive_sync.enable' : 'true' , 'hoodie.datasource.hive_sync.table' : test_tableName , 'hoodie.datasource.hive_sync.database' : 'default' , 'hoodie.datasource.write.hive_style_partitioning' : 'true' , 'hoodie.datasource.hive_sync.partition_fields' : 'creation_date' , 'hoodie.datasource.hive_sync.partition_extractor_class' : 'org.apache.hudi.hive.MultiPartKeysValueExtractor' , 'hoodie.datasource.hive_sync.mode' : 'hms' } # Write a DataFrame as a Hudi dataset inputDF . write \\ . format ( 'org.apache.hudi' ) \\ . option ( 'hoodie.datasource.write.operation' , 'bulk_insert' ) \\ . options ( ** hudiOptions ) \\ . mode ( 'overwrite' ) \\ . save ( sys . argv [ 1 ] + \"/hudi_hive_insert\" ) print ( \"After {} \" . format ( spark . catalog . listTables ())) Request: The latest Hudi-spark3-bundle library is needed to support the new HMS hive sync functionality. In the following sample script, it is downloaded from maven repository when submitting a job with EMR 6.3. Starting from EMR 6.5, you don't need the --jars setting anymore, because EMR 6.5+ includes the Hudi-spark3-bundle library. aws emr-containers start-job-run \\ --virtual-cluster-id $VIRTUAL_CLUSTER_ID \\ --name hudi-test1 \\ --execution-role-arn $EMR_ROLE_ARN \\ --release-label emr-6.3.0-latest \\ --job-driver '{ \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://' $S3BUCKET '/app_code/job/HudiEMRonEKS.py\", \"entryPointArguments\":[\"s3://' $S3BUCKET '\"], \"sparkSubmitParameters\": \"--jars https://repo1.maven.org/maven2/org/apache/hudi/hudi-spark3-bundle_2.12/0.9.0/hudi-spark3-bundle_2.12-0.9.0.jar --conf spark.executor.cores=1 --conf spark.executor.instances=2\"}}' \\ --configuration-overrides '{ \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.serializer\": \"org.apache.spark.serializer.KryoSerializer\", \"spark.sql.hive.convertMetastoreParquet\": \"false\", \"spark.hive.metastore.uris\": \"thrift://localhost:9083\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://' $S3BUCKET '/app_code/job/sidecar_hms_pod_template.yaml\" }} ], \"monitoringConfiguration\": { \"s3MonitoringConfiguration\": {\"logUri\": \"s3://' $S3BUCKET '/elasticmapreduce/emr-containers\"}}}'","title":"5-Hudi + Remote Hive metastore integration"},{"location":"node-placement/docs/","text":"","title":"Index"},{"location":"node-placement/docs/eks-node-placement/","text":"EKS Node Placement \u00b6 Single AZ placement \u00b6 AWS EKS clusters can span multiple AZs in a VPC. A Spark application whose driver and executor pods are distributed across multiple AZs can incur inter-AZ data transfer costs. To minimize or eliminate inter-AZ data transfer costs, you can configure the application to only run on the nodes within a single AZ. In this example, we use the kubernetes node selector to specify which AZ should the job run on. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.kubernetes.node.selector.topology.kubernetes.io/zone='<availability zone>' --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts the driver pod and executor pods are scheduled only on those EKS worker nodes with the label topology.kubernetes.io/zone: <availability zone> . This ensures the spark job is run within a single AZ. If there are not enough resources within the specified AZ, the pods will be in the pending state until the Autoscaler(if configured) kicks in or more resources become available. Spark on kubernetes Node selector configuration Kubernetes Node selector reference Configuration of interest - --conf spark.kubernetes.node.selector.zone='<availability zone>' zone is a built in label that EKS assigns to every EKS worker Node. The above config will ensure to schedule the driver and executor pod on those EKS worker nodes labeled - topology.kubernetes.io/zone: <availability zone> . However, user defined labels can also be assigned to EKS worker nodes and used as node selector. Other common use cases are using node labels to force the job to run on on demand/spot, machine type, etc. Single AZ and ec2 instance type placement \u00b6 Multiple key value pairs for spark.kubernetes.node.selector.[labelKey] can be passed to add filter conditions for selecting the EKS worker node. If you want to schedule on EKS worker nodes in <availability zone> and instance-type as m5.4xlarge - it is done as below Request: { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\", \"spark.kubernetes.node.selector.topology.kubernetes.io/zone\":\"<availability zone>\", \"spark.kubernetes.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } } } Configuration of interest spark.kubernetes.node.selector.[labelKey] - Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration's value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.","title":"EKS Node placement"},{"location":"node-placement/docs/eks-node-placement/#eks-node-placement","text":"","title":"EKS Node Placement"},{"location":"node-placement/docs/eks-node-placement/#single-az-placement","text":"AWS EKS clusters can span multiple AZs in a VPC. A Spark application whose driver and executor pods are distributed across multiple AZs can incur inter-AZ data transfer costs. To minimize or eliminate inter-AZ data transfer costs, you can configure the application to only run on the nodes within a single AZ. In this example, we use the kubernetes node selector to specify which AZ should the job run on. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.kubernetes.node.selector.topology.kubernetes.io/zone='<availability zone>' --conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts the driver pod and executor pods are scheduled only on those EKS worker nodes with the label topology.kubernetes.io/zone: <availability zone> . This ensures the spark job is run within a single AZ. If there are not enough resources within the specified AZ, the pods will be in the pending state until the Autoscaler(if configured) kicks in or more resources become available. Spark on kubernetes Node selector configuration Kubernetes Node selector reference Configuration of interest - --conf spark.kubernetes.node.selector.zone='<availability zone>' zone is a built in label that EKS assigns to every EKS worker Node. The above config will ensure to schedule the driver and executor pod on those EKS worker nodes labeled - topology.kubernetes.io/zone: <availability zone> . However, user defined labels can also be assigned to EKS worker nodes and used as node selector. Other common use cases are using node labels to force the job to run on on demand/spot, machine type, etc.","title":"Single AZ placement"},{"location":"node-placement/docs/eks-node-placement/#single-az-and-ec2-instance-type-placement","text":"Multiple key value pairs for spark.kubernetes.node.selector.[labelKey] can be passed to add filter conditions for selecting the EKS worker node. If you want to schedule on EKS worker nodes in <availability zone> and instance-type as m5.4xlarge - it is done as below Request: { \"name\": \"spark-python-in-s3-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\", \"spark.kubernetes.node.selector.topology.kubernetes.io/zone\":\"<availability zone>\", \"spark.kubernetes.node.selector.node.kubernetes.io/instance-type\":\"m5.4xlarge\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } } } Configuration of interest spark.kubernetes.node.selector.[labelKey] - Adds to the node selector of the driver pod and executor pods, with key labelKey and the value as the configuration's value. For example, setting spark.kubernetes.node.selector.identifier to myIdentifier will result in the driver pod and executors having a node selector with key identifier and value myIdentifier. Multiple node selector keys can be added by setting multiple configurations with this prefix.","title":"Single AZ and ec2 instance type placement"},{"location":"node-placement/docs/fargate-node-placement/","text":"EKS Fargate Node Placement \u00b6 Fargate Node Placement \u00b6 AWS Fargate is a technology that provides on-demand, right-sized compute capacity for containers. With AWS Fargate, you don't have to provision, configure, or scale groups of EC2 instances on your own to run containers. You also don't need to choose server types, decide when to scale your node groups, or optimize cluster packing. Instead you can control which pods start on Fargate and how they run with Fargate profiles. AWS Fargate profile \u00b6 Before you can schedule pods on Fargate in your cluster, you must define at least one Fargate profile that specifies which pods use Fargate when launched. You must define a namespace for every selector. The Fargate profile allows an administrator to declare which pods run on Fargate. This declaration is done through the profile\u2019s selectors. If a namespace selector is defined without any labels, Amazon EKS attempts to schedule all pods that run in that namespace onto Fargate using the profile. Create Fargate Profile Create your Fargate profile with the following eksctl command, replacing the <variable text> (including <>) with your own values. You're required to specify a namespace. The --labels option is not required to create your Fargate profile, but will be required if you want to only run Spark executors on Fargate. eksctl create fargateprofile \\ --cluster <cluster_name> \\ --name <fargate_profile_name> \\ --namespace <virtual_cluster_mapped_namespace> \\ --labels spark-node-placement=fargate 1- Place entire job including driver pod on Fargate \u00b6 When both Driver and Executors use the same labels as the Fargate Selector, the entire job including the driver pod will run on Fargate. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=4 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod and executor pods are scheduled only on Fargate since both are labeled with the spark-node-placement: fargate . This is useful when we want to run the entire job on Fargate nodes. The maximum vCPU available for the driver pod is 4vCPU. 2- Place driver pod on EC2 and executor pod on Fargate \u00b6 Remove the label from the driver pod to schedule the driver pod on EC2 instances. This is especially helpful when driver pod needs more resources (i.e. > 4 vCPU). Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=6 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod schedules on an EC2 instance. EKS picks an instance from the first Node Group that has the matching resources available to the driver pod. 3- Define a NodeSelector in Pod Templates \u00b6 Beginning with Amazon EMR versions 5.33.0 or 6.3.0, Amazon EMR on EKS supports Spark\u2019s pod template feature. Pod templates are specifications that determine how to run each pod. You can use pod template files to define the driver or executor pod\u2019s configurations that Spark configurations do not support. For example Spark configurations do not support defining individual node selectors for the driver pod and the executor pods. Define a node selector only for the driver pod when you want to choose on which pool of EC2 instance it should schedule. Let the Fargate Profile schedule the executor pods. Driver Pod Template apiVersion: v1 kind: Pod spec: volumes: - name: source-data-volume emptyDir: {} - name: metrics-files-volume emptyDir: {} nodeSelector: <ec2-instance-node-label-key>: <ec2-instance-node-label-value> containers: - name: spark-kubernetes-driver # This will be interpreted as Spark driver container Store the pod template file onto a S3 location: aws s3 cp /driver-pod-template.yaml s3://<your-bucket-name>/driver-pod-template.yaml Request cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<your-bucket-name>/driver-pod-template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: The driver pod schedules on an EC2 instance with enough capacity and matching label key / value with the node selector.","title":"EKS Fargate Node placement"},{"location":"node-placement/docs/fargate-node-placement/#eks-fargate-node-placement","text":"","title":"EKS Fargate Node Placement"},{"location":"node-placement/docs/fargate-node-placement/#fargate-node-placement","text":"AWS Fargate is a technology that provides on-demand, right-sized compute capacity for containers. With AWS Fargate, you don't have to provision, configure, or scale groups of EC2 instances on your own to run containers. You also don't need to choose server types, decide when to scale your node groups, or optimize cluster packing. Instead you can control which pods start on Fargate and how they run with Fargate profiles.","title":"Fargate Node Placement"},{"location":"node-placement/docs/fargate-node-placement/#aws-fargate-profile","text":"Before you can schedule pods on Fargate in your cluster, you must define at least one Fargate profile that specifies which pods use Fargate when launched. You must define a namespace for every selector. The Fargate profile allows an administrator to declare which pods run on Fargate. This declaration is done through the profile\u2019s selectors. If a namespace selector is defined without any labels, Amazon EKS attempts to schedule all pods that run in that namespace onto Fargate using the profile. Create Fargate Profile Create your Fargate profile with the following eksctl command, replacing the <variable text> (including <>) with your own values. You're required to specify a namespace. The --labels option is not required to create your Fargate profile, but will be required if you want to only run Spark executors on Fargate. eksctl create fargateprofile \\ --cluster <cluster_name> \\ --name <fargate_profile_name> \\ --namespace <virtual_cluster_mapped_namespace> \\ --labels spark-node-placement=fargate","title":"AWS Fargate profile"},{"location":"node-placement/docs/fargate-node-placement/#1-place-entire-job-including-driver-pod-on-fargate","text":"When both Driver and Executors use the same labels as the Fargate Selector, the entire job including the driver pod will run on Fargate. Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=4 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.driver.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod and executor pods are scheduled only on Fargate since both are labeled with the spark-node-placement: fargate . This is useful when we want to run the entire job on Fargate nodes. The maximum vCPU available for the driver pod is 4vCPU.","title":"1- Place entire job including driver pod on Fargate"},{"location":"node-placement/docs/fargate-node-placement/#2-place-driver-pod-on-ec2-and-executor-pod-on-fargate","text":"Remove the label from the driver pod to schedule the driver pod on EC2 instances. This is especially helpful when driver pod needs more resources (i.e. > 4 vCPU). Request: cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=6 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: When the job starts, the driver pod schedules on an EC2 instance. EKS picks an instance from the first Node Group that has the matching resources available to the driver pod.","title":"2- Place driver pod on EC2 and executor pod on Fargate"},{"location":"node-placement/docs/fargate-node-placement/#3-define-a-nodeselector-in-pod-templates","text":"Beginning with Amazon EMR versions 5.33.0 or 6.3.0, Amazon EMR on EKS supports Spark\u2019s pod template feature. Pod templates are specifications that determine how to run each pod. You can use pod template files to define the driver or executor pod\u2019s configurations that Spark configurations do not support. For example Spark configurations do not support defining individual node selectors for the driver pod and the executor pods. Define a node selector only for the driver pod when you want to choose on which pool of EC2 instance it should schedule. Let the Fargate Profile schedule the executor pods. Driver Pod Template apiVersion: v1 kind: Pod spec: volumes: - name: source-data-volume emptyDir: {} - name: metrics-files-volume emptyDir: {} nodeSelector: <ec2-instance-node-label-key>: <ec2-instance-node-label-value> containers: - name: spark-kubernetes-driver # This will be interpreted as Spark driver container Store the pod template file onto a S3 location: aws s3 cp /driver-pod-template.yaml s3://<your-bucket-name>/driver-pod-template.yaml Request cat >spark-python-in-s3-nodeselector.json << EOF { \"name\": \"spark-python-in-s3-fargate-nodeselector\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.3.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=30G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.executor.label.spark-node-placement\": \"fargate\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<your-bucket-name>/driver-pod-template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-nodeselector.json Observed Behavior: The driver pod schedules on an EC2 instance with enough capacity and matching label key / value with the node selector.","title":"3- Define a NodeSelector in Pod Templates"},{"location":"outposts/","text":"","title":"Index"},{"location":"outposts/emr-containers-on-outposts/","text":"Running EMR Containers on AWS Outposts \u00b6 Background \u00b6 You can now run Amazon EMR container jobs on EKS clusters that are running on AWS Outposts. AWS Outposts enables native AWS services, infrastructure, and operating models in on-premises facilities. In AWS Outposts environments, you can use the same AWS APIs, tools, and infrastructure that you use in the AWS Cloud. Amazon EKS nodes on AWS Outposts is ideal for low-latency workloads that need to be run in close proximity to on-premises data and applications. For more information, see the Amazon EKS on Outposts documentation page . This document provides the steps to set up EMR containers on AWS Outposts. Key Considerations and Recommendations \u00b6 The EKS cluster on an Outpost must be created with self-managed node groups. Use the AWS Management Console and AWS CloudFormation to create a self-managed node group in Outposts. For EMR workloads, we recommend creating EKS clusters where all the worker nodes reside in the self-managed node group of Outposts. The Kubernetes client in the Spark driver pod creates and monitor executor pods by communicating with the EKS managed Kubernetes API server residing in the parent AWS Region. For reliable monitoring of executor pods during a job run, we also recommend having a reliable low latency link between the Outpost and the parent Region. AWS Fargate is not available on Outposts. For more information about the supported Regions, prerequisites and considerations for Amazon EKS on AWS Outposts, see the EKS on Outposts documentation page . Infrastructure Setup \u00b6 Setup EKS on Outposts \u00b6 Network Setup Setup a VPC aws ec2 create - vpc \\ -- region < us - west - 2 > \\ -- cidr - block ' < 10.0.0.0 / 16 > ' In the output, take note of the VPC ID. { \"Vpc\": { \"VpcId\": \"vpc-123vpc\", ... } } Create two subnets in the parent Region. aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.1.0 / 24 > ' aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az2 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.2.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-111\", ... } } { \"Subnet\": { \"SubnetId\": \"subnet-222\", ... } } Create a subnet in the Outpost Availability Zone. (This step is different for Outposts) aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- outpost - arn ' arn:aws:outposts: < us - west - 2 >:< 123456789 >: outpost /< op - 123 op > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.3.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-333outpost\", \"OutpostArn\": \"...\" ... } } EKS Cluster Creation Create an EKS cluster using the three subnet Ids created earlier. aws eks create - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' \\ -- role - arn ' arn:aws: iam ::< 123456789 >: role /< cluster - service - role > ' \\ -- resources - vpc - config subnetIds = ' < subnet - 111 > , < subnet - 222 > , < subnet - 333 outpost > ' Check until the cluster status becomes active. aws eks describe - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' Note the values of resourcesVpcConfig.clusterSecurityGroupId and identity.oidc.issuer. { \"cluster\": { \"name\": \"outposts-eks-cluster\", ... \"resourcesVpcConfig\": { \"clusterSecurityGroupId\": \"sg-123clustersg\", }, \"identity\": { \"oidc\": { \"issuer\": \"https://oidc.eks.us-west-2.amazonaws.com/id/oidcid\" } }, \"status\": \"ACTIVE\", } } Add the Outposts nodes to the EKS Cluster. At this point, eksctl cannot be used to launch self-managed node groups in Outposts. Please follow the steps listed in the self-managed nodes documentation page . In order to use the cloudformation script lised in the AWS Management Console tab, make note of the following values created in the earlier steps: * ClusterName: <outposts-eks-cluster> * ClusterControlPlaneSecurityGroup: <sg-123clustersg> * Subnets: <subnet-333outpost> Apply the aws-auth-cm config map listed on the documentation page to allow the nodes to join the cluster. Register cluster with EMR Containers \u00b6 Once the EKS cluster has been created and the nodes have been registered with the EKS control plane, take the following steps : Enable cluster access for Amazon EMR on EKS. Enable IAM Roles for Service Accounts (IRSA) on the EKS cluster. Create a job execution role. Update the trust policy of the job execution role. Grant users access to Amazon EMR on EKS. Register the Amazon EKS cluster with Amazon EMR. Conclusion \u00b6 EMR-EKS on Outposts allows users to run their big data jobs in close proximity to on-premises data and applications.","title":"EMR on EKS(AWS Outposts)"},{"location":"outposts/emr-containers-on-outposts/#running-emr-containers-on-aws-outposts","text":"","title":"Running EMR Containers on AWS Outposts"},{"location":"outposts/emr-containers-on-outposts/#background","text":"You can now run Amazon EMR container jobs on EKS clusters that are running on AWS Outposts. AWS Outposts enables native AWS services, infrastructure, and operating models in on-premises facilities. In AWS Outposts environments, you can use the same AWS APIs, tools, and infrastructure that you use in the AWS Cloud. Amazon EKS nodes on AWS Outposts is ideal for low-latency workloads that need to be run in close proximity to on-premises data and applications. For more information, see the Amazon EKS on Outposts documentation page . This document provides the steps to set up EMR containers on AWS Outposts.","title":"Background"},{"location":"outposts/emr-containers-on-outposts/#key-considerations-and-recommendations","text":"The EKS cluster on an Outpost must be created with self-managed node groups. Use the AWS Management Console and AWS CloudFormation to create a self-managed node group in Outposts. For EMR workloads, we recommend creating EKS clusters where all the worker nodes reside in the self-managed node group of Outposts. The Kubernetes client in the Spark driver pod creates and monitor executor pods by communicating with the EKS managed Kubernetes API server residing in the parent AWS Region. For reliable monitoring of executor pods during a job run, we also recommend having a reliable low latency link between the Outpost and the parent Region. AWS Fargate is not available on Outposts. For more information about the supported Regions, prerequisites and considerations for Amazon EKS on AWS Outposts, see the EKS on Outposts documentation page .","title":"Key Considerations and Recommendations"},{"location":"outposts/emr-containers-on-outposts/#infrastructure-setup","text":"","title":"Infrastructure Setup"},{"location":"outposts/emr-containers-on-outposts/#setup-eks-on-outposts","text":"Network Setup Setup a VPC aws ec2 create - vpc \\ -- region < us - west - 2 > \\ -- cidr - block ' < 10.0.0.0 / 16 > ' In the output, take note of the VPC ID. { \"Vpc\": { \"VpcId\": \"vpc-123vpc\", ... } } Create two subnets in the parent Region. aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.1.0 / 24 > ' aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az2 > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.2.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-111\", ... } } { \"Subnet\": { \"SubnetId\": \"subnet-222\", ... } } Create a subnet in the Outpost Availability Zone. (This step is different for Outposts) aws ec2 create - subnet \\ -- region ' < us - west - 2 > ' \\ -- availability - zone - id ' < usw2 - az1 > ' \\ -- outpost - arn ' arn:aws:outposts: < us - west - 2 >:< 123456789 >: outpost /< op - 123 op > ' \\ -- vpc - id ' < vpc - 123 vpc > ' \\ -- cidr - block ' < 10.0.3.0 / 24 > ' In the output, take note of the Subnet ID. { \"Subnet\": { \"SubnetId\": \"subnet-333outpost\", \"OutpostArn\": \"...\" ... } } EKS Cluster Creation Create an EKS cluster using the three subnet Ids created earlier. aws eks create - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' \\ -- role - arn ' arn:aws: iam ::< 123456789 >: role /< cluster - service - role > ' \\ -- resources - vpc - config subnetIds = ' < subnet - 111 > , < subnet - 222 > , < subnet - 333 outpost > ' Check until the cluster status becomes active. aws eks describe - cluster \\ -- region ' < us - west - 2 > ' \\ -- name ' < outposts - eks - cluster > ' Note the values of resourcesVpcConfig.clusterSecurityGroupId and identity.oidc.issuer. { \"cluster\": { \"name\": \"outposts-eks-cluster\", ... \"resourcesVpcConfig\": { \"clusterSecurityGroupId\": \"sg-123clustersg\", }, \"identity\": { \"oidc\": { \"issuer\": \"https://oidc.eks.us-west-2.amazonaws.com/id/oidcid\" } }, \"status\": \"ACTIVE\", } } Add the Outposts nodes to the EKS Cluster. At this point, eksctl cannot be used to launch self-managed node groups in Outposts. Please follow the steps listed in the self-managed nodes documentation page . In order to use the cloudformation script lised in the AWS Management Console tab, make note of the following values created in the earlier steps: * ClusterName: <outposts-eks-cluster> * ClusterControlPlaneSecurityGroup: <sg-123clustersg> * Subnets: <subnet-333outpost> Apply the aws-auth-cm config map listed on the documentation page to allow the nodes to join the cluster.","title":"Setup EKS on Outposts"},{"location":"outposts/emr-containers-on-outposts/#register-cluster-with-emr-containers","text":"Once the EKS cluster has been created and the nodes have been registered with the EKS control plane, take the following steps : Enable cluster access for Amazon EMR on EKS. Enable IAM Roles for Service Accounts (IRSA) on the EKS cluster. Create a job execution role. Update the trust policy of the job execution role. Grant users access to Amazon EMR on EKS. Register the Amazon EKS cluster with Amazon EMR.","title":"Register cluster with EMR Containers"},{"location":"outposts/emr-containers-on-outposts/#conclusion","text":"EMR-EKS on Outposts allows users to run their big data jobs in close proximity to on-premises data and applications.","title":"Conclusion"},{"location":"performance/docs/","text":"","title":"Index"},{"location":"performance/docs/dra/","text":"Dynamic Resource Allocation \u00b6 DRA is available in Spark 3 (EMR 6.x) without the need for an external shuffle service. Spark on Kubernetes doesn't support external shuffle service as of spark 3.1, but DRA can be achieved by enabling shuffle tracking . Spark DRA without external shuffle service: With DRA, the spark driver spawns the initial number of executors and then scales up the number until the specified maximum number of executors is met to process the pending tasks. Idle executors are terminated when there are no pending tasks, the executor idle time exceeds the idle timeout( spark.dynamicAllocation.executorIdleTimeout) and it doesn't have any cached or shuffle data. If the executor idle threshold is reached and it has cached data, then it has to exceed the cache data idle timeout( spark.dynamicAllocation.cachedExecutorIdleTimeout) and if the executor doesn't have shuffle data, then the idle executor is terminated. If the executor idle threshold is reached and it has shuffle data, then without external shuffle service the executor will never be terminated. These executors will be terminated when the job is completed. This behavior is enforced by \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\" and \"spark.dynamicAllocation.enabled\":\"true\" If \"spark.dynamicAllocation.shuffleTracking.enabled\":\"false\"and \"spark.dynamicAllocation.enabled\":\"true\" then the spark application will error out since external shuffle service is not available. Request: cat >spark-python-in-s3-dra.json << EOF { \"name\": \"spark-python-in-s3-dra\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"true\", \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\", \"spark.dynamicAllocation.minExecutors\":\"5\", \"spark.dynamicAllocation.maxExecutors\":\"100\", \"spark.dynamicAllocation.initialExecutors\":\"10\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dra.json Observed Behavior: When the job gets started, the driver pod gets created and 10 executors are initially created. ( \"spark.dynamicAllocation.initialExecutors\":\"10\" ) Then the number of executors can scale up to a maximum of 100 ( \"spark.dynamicAllocation.maxExecutors\":\"100\" ). Configurations to note: Please note that this feature is marked as Experimental as of Spark 3.0.0 spark.dynamicAllocation.shuffleTracking.enabled - ** Experimental ** . Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs. spark.dynamicAllocation.shuffleTracking.timeout - When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.","title":"Dynamic Resource Allocation"},{"location":"performance/docs/dra/#dynamic-resource-allocation","text":"DRA is available in Spark 3 (EMR 6.x) without the need for an external shuffle service. Spark on Kubernetes doesn't support external shuffle service as of spark 3.1, but DRA can be achieved by enabling shuffle tracking . Spark DRA without external shuffle service: With DRA, the spark driver spawns the initial number of executors and then scales up the number until the specified maximum number of executors is met to process the pending tasks. Idle executors are terminated when there are no pending tasks, the executor idle time exceeds the idle timeout( spark.dynamicAllocation.executorIdleTimeout) and it doesn't have any cached or shuffle data. If the executor idle threshold is reached and it has cached data, then it has to exceed the cache data idle timeout( spark.dynamicAllocation.cachedExecutorIdleTimeout) and if the executor doesn't have shuffle data, then the idle executor is terminated. If the executor idle threshold is reached and it has shuffle data, then without external shuffle service the executor will never be terminated. These executors will be terminated when the job is completed. This behavior is enforced by \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\" and \"spark.dynamicAllocation.enabled\":\"true\" If \"spark.dynamicAllocation.shuffleTracking.enabled\":\"false\"and \"spark.dynamicAllocation.enabled\":\"true\" then the spark application will error out since external shuffle service is not available. Request: cat >spark-python-in-s3-dra.json << EOF { \"name\": \"spark-python-in-s3-dra\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/trip-count.py\", \"sparkSubmitParameters\": \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"true\", \"spark.dynamicAllocation.shuffleTracking.enabled\":\"true\", \"spark.dynamicAllocation.minExecutors\":\"5\", \"spark.dynamicAllocation.maxExecutors\":\"100\", \"spark.dynamicAllocation.initialExecutors\":\"10\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dra.json Observed Behavior: When the job gets started, the driver pod gets created and 10 executors are initially created. ( \"spark.dynamicAllocation.initialExecutors\":\"10\" ) Then the number of executors can scale up to a maximum of 100 ( \"spark.dynamicAllocation.maxExecutors\":\"100\" ). Configurations to note: Please note that this feature is marked as Experimental as of Spark 3.0.0 spark.dynamicAllocation.shuffleTracking.enabled - ** Experimental ** . Enables shuffle file tracking for executors, which allows dynamic allocation without the need for an external shuffle service. This option will try to keep alive executors that are storing shuffle data for active jobs. spark.dynamicAllocation.shuffleTracking.timeout - When shuffle tracking is enabled, controls the timeout for executors that are holding shuffle data. The default value means that Spark will rely on the shuffles being garbage collected to be able to release executors. If for some reason garbage collection is not cleaning up shuffles quickly enough, this option can be used to control when to time out executors even when they are storing shuffle data.","title":"Dynamic Resource Allocation"},{"location":"security/docs/","text":"","title":"Index"},{"location":"security/docs/spark/data-encryption/","text":"EMR Containers Spark - In transit and At Rest data encryption \u00b6 Encryption at Rest \u00b6 Amazon S3 Client-Side Encryption \u00b6 To utilize S3 Client side encryption , you will need to create a KMS Key to be used to encrypt and decrypt data. If you do not have an KMS key, please follow this guide - AWS KMS create keys . Also please note the job execution role needs access to this key, please see Add to Key policy for instructions on how to add these permissions. trip-count-encrypt-write.py: cat > trip - count - encrypt - write . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () EOF Request: cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json In the above request, EMRFS encrypts the parquet file with the specified KMS key and the encrypted object is persisted to the specified s3 location. To verify the encryption - use the same KMS key to decrypt - the KMS key used is a symmetric key ( the same key can be used to both encrypt and decrypt) trip-count-encrypt-read.py cat > trip - count - encrypt - read . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df_encrypt = spark . read . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt data - Total trips: \" + str ( df_encrypt . count ())) spark . stop () EOF Request cat > spark-python-in-s3-encrypt-cse-kms-read.json<<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-read\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-read.json Validate encryption: Try to read the encrypted data without specifying \"fs.s3.cse.enabled\":\"true\" - will get an error message in the driver and executor logs because the content is encrypted and cannot be read without decryption.","title":"Data Encryption"},{"location":"security/docs/spark/data-encryption/#emr-containers-spark-in-transit-and-at-rest-data-encryption","text":"","title":"EMR Containers Spark - In transit and At Rest data encryption"},{"location":"security/docs/spark/data-encryption/#encryption-at-rest","text":"","title":"Encryption at Rest"},{"location":"security/docs/spark/data-encryption/#amazon-s3-client-side-encryption","text":"To utilize S3 Client side encryption , you will need to create a KMS Key to be used to encrypt and decrypt data. If you do not have an KMS key, please follow this guide - AWS KMS create keys . Also please note the job execution role needs access to this key, please see Add to Key policy for instructions on how to add these permissions. trip-count-encrypt-write.py: cat > trip - count - encrypt - write . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () EOF Request: cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json In the above request, EMRFS encrypts the parquet file with the specified KMS key and the encrypted object is persisted to the specified s3 location. To verify the encryption - use the same KMS key to decrypt - the KMS key used is a symmetric key ( the same key can be used to both encrypt and decrypt) trip-count-encrypt-read.py cat > trip - count - encrypt - read . py << EOF import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df_encrypt = spark . read . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt data - Total trips: \" + str ( df_encrypt . count ())) spark . stop () EOF Request cat > spark-python-in-s3-encrypt-cse-kms-read.json<<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-read\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-read.json Validate encryption: Try to read the encrypted data without specifying \"fs.s3.cse.enabled\":\"true\" - will get an error message in the driver and executor logs because the content is encrypted and cannot be read without decryption.","title":"Amazon S3 Client-Side Encryption"},{"location":"security/docs/spark/encryption/","text":"EMR on EKS - Encryption Best Practices \u00b6 This document will describe how to think about security and its best practices when applying to EMR on EKS service. We will cover topics related to encryption at rest and in-transit when you run EMR on EKS jobs on EKS cluster. Its important to understand the shared responsibility model when using managed services such as EMR on EKS in order to improve the overall security posture of your environment. Generally speaking AWS is responsible for security \"of\" the cloud whereas you, the customer, are responsible for security \"in\" the cloud. The diagram below depicts this high level definition. Shared responsibility model \u00b6 EMR on EKS provides simple way to run spark jobs on top of EKS clusters. The architecture itself is loosely coupled and is abstracted from customers so that they can run secure environment for running spark applications. Because EMR on EKS uses combination of two services (EMR and EKS) at a minimal, we will cover how EKS enables infrastructure components that are consumable by EMR spark workload and how to handle encryption for each service. AWS assumes different levels of responsibility depending on the features being consumed by EMR on EKS customers. At this time of writing, the features from EKS are managed node groups, self-managed workers, and Fargate. We won\u2019t go in-depth on these architectures as they are detailed in EKS best practices guide (https://aws.github.io/aws-eks-best-practices/security/docs/). Below diagrams depict how this responsibility changes between customer and AWS based on consumed features. Encryption for data in-transit \u00b6 In this section, we will cover encryption for data in-transit. We will highlight AWS platform capabilities from the physical layer and then review how AWS handles encryption in the EMR on EKS architecture layer. Lastly, we will cover how customers can enable encryption between spark drivers and executors. AWS Infrastructure - Physical layer \u00b6 AWS provides secure and private connectivity between EC2 instances of all types. All data flowing across AWS Regions over the AWS global network is automatically encrypted at the physical layer before it leaves AWS secured facilities. All traffic between AZs is encrypted. All cross-Region traffic that uses Amazon VPC and Transit Gateway peering is automatically bulk-encrypted when it exits a Region. In addition, if you use Nitro family of instances, all traffic between instances is encrypted in-transit using AEAD algorithms with 256-bit encryption. We highly recommend reviewing EC2 documentation for more information. Amazon EMR on EKS \u00b6 Below diagram depicts high-level architecture implementation of EMR on EKS. In this section, we will cover encryption in-transit for communication between managed services such as EMR & EKS. All traffic with AWS API\u2019s that support EMR and EKS are encrypted by default. EKS enables Kubernetes API server using https endpoint. Both the kubelet that runs on EKS worker nodes and Kubernetes client such as kubectl interacts with EKS cluster API using TLS. Amazon EMR on EKS uses the same secure channel to interact with EKS cluster API to run spark jobs on worker nodes. In addition, EMR on EKS provides an encrypted endpoint for accessing spark history server. Spark offers AES-based encryption for RPC connections. EMR on EKS customers may choose to encrypt the traffic between spark drivers and executors using this encryption mechanism. In order to enable encryption, RPC authentication must also be enabled in your spark configuration. --conf spark.authenticate=true \\ --conf spark.network.crypto.enabled=true \\ The encryption key is generated by the driver and distributed to executors via environment variables. Because these environment variables can be accessed by users who has access to Kubernetes API (kubectl), we recommend securing access so that only authorized users have access to your environment. You should also configure proper Kubernetes RBAC permissions so that only authorized service accounts can use these variables. Encryption for data at-rest \u00b6 In this section, we will cover encryption for data at-rest. We will review how to enable storage-level encryption so that it is transparent for spark application to use this data securely. We will also see how to enable encryption from spark application while using AWS native storage options. Amazon S3 \u00b6 Amazon S3 offers server-side encryption for encrypting all data that is stored in an S3 bucket. You can enable default encryption using either S3 managed keys (SSE-S3) or KMS managed keys (SSE-KMS). Amazon S3 will encrypt all data before storing it on disks based on the keys specified. We recommend using server-side encryption at a minimum so that your data at-rest is encrypted. Please review Amazon S3 documentation and use the mechanisms that apply to your encryption standards and acceptable performance. Amazon S3 supports client-side encryption as well. Using this approach, you can let spark application to encrypt all data with desired KMS keys and upload this data to S3 buckets. Below examples shows spark application reading and writing parquet data in S3. During job submission, we use EMRFS encryption mechanism to encrypt all data with KMS key into the desired S3 location. import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () Below is the job submission request that depicts KMS specification needed for EMRFS to perform this encryption. For complete end-to-end example, please see EMR on EKS best practices documentation cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json Amazon EKS offers three different storage offerings (EBS, EFS, FSx) that can be directly consumed by pods. Each storage offering provides encryption mechanism that can be enabled at the storage level. Amazon EBS \u00b6 Amazon EBS supports default encryption that can be turned on a per region basis. Once its turned on, you can have newly created EBS volumes and snapshots encrypted using AWS managed KMS keys. Please review EBS documentation to learn more on how to enable this feature You can use Kubernetes (k8s) in-tree storage driver or choose to use EBS CSI driver to consume EBS volumes within your pods. Both choices offer options to enable encryption. In the below example, we use k8s in-tree storage driver to create storage class and persistent volume claim . You can create similar resources using EBS CSI driver as well. apiVersion : storage . k8s . io / v1 kind : StorageClass metadata : name : encrypted - sc provisioner : kubernetes . io / aws - ebs volumeBindingMode : WaitForFirstConsumer parameters : type : gp2 fsType : ext4 encrypted : \"true\" apiVersion : v1 kind : PersistentVolumeClaim metadata : name : spark - driver - pvc spec : storageClassName : encrypted - sc accessModes : - ReadWriteOnce resources : requests : storage : 10 Gi Once these resources are created, you can specify them in your drivers and executors. You can see an example of this specification below. --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data ... --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=spark-executor-pvc --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data Another approach is to let k8s create EBS volumes dynamically based on your spark workload. You can do so by specifying just the storageClass and sizeLimit options and specify OnDemand for the persistent volume claim (PVC). This is useful in case of Dynamic Resource Allocation . Please be sure to use EMR 6.3.0 release and above to use this feature because dynamic PVC support was added in Spark 3.1. Below is an example for dynamically creating volumes for executors within your job -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . options . claimName = spark - driver - pvc -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . path =/ var / data / spill -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . readOnly = false For a complete list of available options, please refer to the Spark Documentation Amazon EFS \u00b6 Similar to EBS, you can consume EFS volumes via EFS CSI driver and FSx for Lustre volumes via FSx CSI driver . There are two provisioning methods before these storage volumes are consumed by workloads, namely static provisioning and dynamic provisioning. For static provisioning, you have to pre-create volumes using AWS API\u2019s, CLI or AWS console. For dynamic provisioning, volume is created dynamically by the CSI drivers as workloads are deployed onto Kubernetes cluster. Currently, EFS CSI driver doesn\u2019t support dynamic volume provisioning. However, you can create the volume using EFS API or AWS console before creating a persistent volume (PV) that can be used within your spark application. If you plan to encrypt the data stored in EFS, you need to specify encryption during volume creation. For further information about EFS file encryption, please refer to Encrypting Data at Rest . One of the advantages of using EFS is that it provides encryption in transit support using TLS and its enabled by default by the CSI driver. You can see the example below if you need to enforce TLS encryption during PV creation apiVersion : v1 kind : PersistentVolume metadata : name : efs - pv spec : capacity : storage : 5 Gi volumeMode : Filesystem accessModes : - ReadWriteOnce persistentVolumeReclaimPolicy : Retain storageClassName : efs - sc csi : driver : efs . csi . aws . com volumeHandle : fs - 4 af69aab volumeAttributes : encryptInTransit : \"true\" Amazon FSx for Lustre \u00b6 Amazon FSx CSI driver supports both static and dynamic provisioning. Encryption for data in-transit is automatically enabled from Amazon EC2 instances that support encryption in transit. To learn which EC2 instances support encryption in transit, see Encryption in Transit in the Amazon EC2 User Guide for Linux Instances. Encryption for data at rest is automatically enabled when you create the FSx filesystem. Amazon FSx for Lustre supports two types of filesystems, namely persistent and scratch. You can use the default encryption method where encryption keys are managed by Amazon FSx. However, if you prefer to manage your own KMS keys, you can do so for persistent filesystem. The example below shows how to create storage class using FSx for Lustre for persistent filesystem using your own KMS managed keys. kind : StorageClass apiVersion : storage . k8s . io / v1 metadata : name : fsx - sc provisioner : fsx . csi . aws . com parameters : subnetId : subnet - 056 da83524edbe641 securityGroupIds : sg - 086 f61ea73388fb6b deploymentType : PERSISTENT_1 kmsKeyId : < kms_arn > You can then create persistent volume claim (see an example in FSx repo ) and use within your spark application as below --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=fsx-claim --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data Using Spark to encrypt data \u00b6 Apache Spark supports encrypting temporary data that is stored on storage volumes. These volumes can be instance storage such as NVMe SSD volumes , EBS, EFS or FSx volumes. Temporary data can be shuffle files, shuffle spills and data blocks stored on disk (for both caching and broadcast variables). Its important to note that the data on NVMe instance storage is encrypted using an XTS-AES-256 block cipher implemented in a hardware module on the instance. Even though, instance storage is available, you need to format and mount them while you bootstrap EC2 instances. Below is an example to show how to use instance storage using eksctl managedNodeGroups: - name: nvme minSize: 2 desiredCapacity: 2 maxSize: 10 instanceType: r5d.4xlarge ssh: enableSsm: true preBootstrapCommands: - IDX=1 - for DEV in /dev/disk/by-id/nvme-Amazon_EC2_NVMe_Instance_Storage_*-ns-1; do mkfs.xfs ${ DEV } ;mkdir -p /local ${ IDX } ;echo ${ DEV } /local ${ IDX } xfs defaults,noatime 1 2 >> /etc/fstab; IDX=$(( ${ IDX } + 1)); done - mount -a If you use non-NVMe SSD volumes, you can follow the best practice to encrypt shuffle data before you write them to disks. You can see an example below that shows this example. For more information about the type of instance store volume supported by each instance type, see Instance store volumes . --conf spark.io.encryption.enabled=true Conclusion \u00b6 In this document, we covered shared responsibility model for running EMR on EKS workload. We then reviewed platform capabilities available through AWS infrastructure and how to enable encryption for both storage-level and via spark application. To quote Werner Vogels, AWS CTO \u201cSecurity is everyone\u2019s job now, not just the security team\u2019s\u201d. We hope this document provides prescriptive guidance into how to enable encryption for running secure EMR on EKS workload.","title":"Encryption"},{"location":"security/docs/spark/encryption/#emr-on-eks-encryption-best-practices","text":"This document will describe how to think about security and its best practices when applying to EMR on EKS service. We will cover topics related to encryption at rest and in-transit when you run EMR on EKS jobs on EKS cluster. Its important to understand the shared responsibility model when using managed services such as EMR on EKS in order to improve the overall security posture of your environment. Generally speaking AWS is responsible for security \"of\" the cloud whereas you, the customer, are responsible for security \"in\" the cloud. The diagram below depicts this high level definition.","title":"EMR on EKS - Encryption Best Practices"},{"location":"security/docs/spark/encryption/#shared-responsibility-model","text":"EMR on EKS provides simple way to run spark jobs on top of EKS clusters. The architecture itself is loosely coupled and is abstracted from customers so that they can run secure environment for running spark applications. Because EMR on EKS uses combination of two services (EMR and EKS) at a minimal, we will cover how EKS enables infrastructure components that are consumable by EMR spark workload and how to handle encryption for each service. AWS assumes different levels of responsibility depending on the features being consumed by EMR on EKS customers. At this time of writing, the features from EKS are managed node groups, self-managed workers, and Fargate. We won\u2019t go in-depth on these architectures as they are detailed in EKS best practices guide (https://aws.github.io/aws-eks-best-practices/security/docs/). Below diagrams depict how this responsibility changes between customer and AWS based on consumed features.","title":"Shared responsibility model"},{"location":"security/docs/spark/encryption/#encryption-for-data-in-transit","text":"In this section, we will cover encryption for data in-transit. We will highlight AWS platform capabilities from the physical layer and then review how AWS handles encryption in the EMR on EKS architecture layer. Lastly, we will cover how customers can enable encryption between spark drivers and executors.","title":"Encryption for data in-transit"},{"location":"security/docs/spark/encryption/#aws-infrastructure-physical-layer","text":"AWS provides secure and private connectivity between EC2 instances of all types. All data flowing across AWS Regions over the AWS global network is automatically encrypted at the physical layer before it leaves AWS secured facilities. All traffic between AZs is encrypted. All cross-Region traffic that uses Amazon VPC and Transit Gateway peering is automatically bulk-encrypted when it exits a Region. In addition, if you use Nitro family of instances, all traffic between instances is encrypted in-transit using AEAD algorithms with 256-bit encryption. We highly recommend reviewing EC2 documentation for more information.","title":"AWS Infrastructure - Physical layer"},{"location":"security/docs/spark/encryption/#amazon-emr-on-eks","text":"Below diagram depicts high-level architecture implementation of EMR on EKS. In this section, we will cover encryption in-transit for communication between managed services such as EMR & EKS. All traffic with AWS API\u2019s that support EMR and EKS are encrypted by default. EKS enables Kubernetes API server using https endpoint. Both the kubelet that runs on EKS worker nodes and Kubernetes client such as kubectl interacts with EKS cluster API using TLS. Amazon EMR on EKS uses the same secure channel to interact with EKS cluster API to run spark jobs on worker nodes. In addition, EMR on EKS provides an encrypted endpoint for accessing spark history server. Spark offers AES-based encryption for RPC connections. EMR on EKS customers may choose to encrypt the traffic between spark drivers and executors using this encryption mechanism. In order to enable encryption, RPC authentication must also be enabled in your spark configuration. --conf spark.authenticate=true \\ --conf spark.network.crypto.enabled=true \\ The encryption key is generated by the driver and distributed to executors via environment variables. Because these environment variables can be accessed by users who has access to Kubernetes API (kubectl), we recommend securing access so that only authorized users have access to your environment. You should also configure proper Kubernetes RBAC permissions so that only authorized service accounts can use these variables.","title":"Amazon EMR on EKS"},{"location":"security/docs/spark/encryption/#encryption-for-data-at-rest","text":"In this section, we will cover encryption for data at-rest. We will review how to enable storage-level encryption so that it is transparent for spark application to use this data securely. We will also see how to enable encryption from spark application while using AWS native storage options.","title":"Encryption for data at-rest"},{"location":"security/docs/spark/encryption/#amazon-s3","text":"Amazon S3 offers server-side encryption for encrypting all data that is stored in an S3 bucket. You can enable default encryption using either S3 managed keys (SSE-S3) or KMS managed keys (SSE-KMS). Amazon S3 will encrypt all data before storing it on disks based on the keys specified. We recommend using server-side encryption at a minimum so that your data at-rest is encrypted. Please review Amazon S3 documentation and use the mechanisms that apply to your encryption standards and acceptable performance. Amazon S3 supports client-side encryption as well. Using this approach, you can let spark application to encrypt all data with desired KMS keys and upload this data to S3 buckets. Below examples shows spark application reading and writing parquet data in S3. During job submission, we use EMRFS encryption mechanism to encrypt all data with KMS key into the desired S3 location. import sys from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"trip-count-join-fsx\" ) \\ . getOrCreate () df = spark . read . parquet ( 's3://<s3 prefix>/trip-data.parquet' ) print ( \"Total trips: \" + str ( df . count ())) df . write . parquet ( 's3://<s3 prefix>/write-encrypt-trip-data.parquet' ) print ( \"Encrypt - KMS- CSE writew to s3 compeleted\" ) spark . stop () Below is the job submission request that depicts KMS specification needed for EMRFS to perform this encryption. For complete end-to-end example, please see EMR on EKS best practices documentation cat > spark-python-in-s3-encrypt-cse-kms-write.json <<EOF { \"name\": \"spark-python-in-s3-encrypt-cse-kms-write\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>trip-count-encrypt-write.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=10 --conf spark.driver.cores=2 --conf spark.executor.memory=20G --conf spark.driver.memory=20G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } }, { \"classification\": \"emrfs-site\", \"properties\": { \"fs.s3.cse.enabled\":\"true\", \"fs.s3.cse.encryptionMaterialsProvider\":\"com.amazon.ws.emr.hadoop.fs.cse.KMSEncryptionMaterialsProvider\", \"fs.s3.cse.kms.keyId\":\"<KMS Key Id>\" } } ], \"monitoringConfiguration\": { \"persistentAppUI\": \"ENABLED\", \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-encrypt-cse-kms-write.json Amazon EKS offers three different storage offerings (EBS, EFS, FSx) that can be directly consumed by pods. Each storage offering provides encryption mechanism that can be enabled at the storage level.","title":"Amazon S3"},{"location":"security/docs/spark/encryption/#amazon-ebs","text":"Amazon EBS supports default encryption that can be turned on a per region basis. Once its turned on, you can have newly created EBS volumes and snapshots encrypted using AWS managed KMS keys. Please review EBS documentation to learn more on how to enable this feature You can use Kubernetes (k8s) in-tree storage driver or choose to use EBS CSI driver to consume EBS volumes within your pods. Both choices offer options to enable encryption. In the below example, we use k8s in-tree storage driver to create storage class and persistent volume claim . You can create similar resources using EBS CSI driver as well. apiVersion : storage . k8s . io / v1 kind : StorageClass metadata : name : encrypted - sc provisioner : kubernetes . io / aws - ebs volumeBindingMode : WaitForFirstConsumer parameters : type : gp2 fsType : ext4 encrypted : \"true\" apiVersion : v1 kind : PersistentVolumeClaim metadata : name : spark - driver - pvc spec : storageClassName : encrypted - sc accessModes : - ReadWriteOnce resources : requests : storage : 10 Gi Once these resources are created, you can specify them in your drivers and executors. You can see an example of this specification below. --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=spark-driver-pvc --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data ... --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.options.claimName=spark-executor-pvc --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.executor.volumes.persistentVolumeClaim.data.mount.path=/data Another approach is to let k8s create EBS volumes dynamically based on your spark workload. You can do so by specifying just the storageClass and sizeLimit options and specify OnDemand for the persistent volume claim (PVC). This is useful in case of Dynamic Resource Allocation . Please be sure to use EMR 6.3.0 release and above to use this feature because dynamic PVC support was added in Spark 3.1. Below is an example for dynamically creating volumes for executors within your job -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . options . claimName = spark - driver - pvc -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . driver . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . path =/ data -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . data . mount . readOnly = false -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . claimName = OnDemand -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . storageClass = encrypted - sc -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . options . sizeLimit = 10 Gi -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . path =/ var / data / spill -- conf spark . kubernetes . executor . volumes . persistentVolumeClaim . spark - local - dir - spill . mount . readOnly = false For a complete list of available options, please refer to the Spark Documentation","title":"Amazon EBS"},{"location":"security/docs/spark/encryption/#amazon-efs","text":"Similar to EBS, you can consume EFS volumes via EFS CSI driver and FSx for Lustre volumes via FSx CSI driver . There are two provisioning methods before these storage volumes are consumed by workloads, namely static provisioning and dynamic provisioning. For static provisioning, you have to pre-create volumes using AWS API\u2019s, CLI or AWS console. For dynamic provisioning, volume is created dynamically by the CSI drivers as workloads are deployed onto Kubernetes cluster. Currently, EFS CSI driver doesn\u2019t support dynamic volume provisioning. However, you can create the volume using EFS API or AWS console before creating a persistent volume (PV) that can be used within your spark application. If you plan to encrypt the data stored in EFS, you need to specify encryption during volume creation. For further information about EFS file encryption, please refer to Encrypting Data at Rest . One of the advantages of using EFS is that it provides encryption in transit support using TLS and its enabled by default by the CSI driver. You can see the example below if you need to enforce TLS encryption during PV creation apiVersion : v1 kind : PersistentVolume metadata : name : efs - pv spec : capacity : storage : 5 Gi volumeMode : Filesystem accessModes : - ReadWriteOnce persistentVolumeReclaimPolicy : Retain storageClassName : efs - sc csi : driver : efs . csi . aws . com volumeHandle : fs - 4 af69aab volumeAttributes : encryptInTransit : \"true\"","title":"Amazon EFS"},{"location":"security/docs/spark/encryption/#amazon-fsx-for-lustre","text":"Amazon FSx CSI driver supports both static and dynamic provisioning. Encryption for data in-transit is automatically enabled from Amazon EC2 instances that support encryption in transit. To learn which EC2 instances support encryption in transit, see Encryption in Transit in the Amazon EC2 User Guide for Linux Instances. Encryption for data at rest is automatically enabled when you create the FSx filesystem. Amazon FSx for Lustre supports two types of filesystems, namely persistent and scratch. You can use the default encryption method where encryption keys are managed by Amazon FSx. However, if you prefer to manage your own KMS keys, you can do so for persistent filesystem. The example below shows how to create storage class using FSx for Lustre for persistent filesystem using your own KMS managed keys. kind : StorageClass apiVersion : storage . k8s . io / v1 metadata : name : fsx - sc provisioner : fsx . csi . aws . com parameters : subnetId : subnet - 056 da83524edbe641 securityGroupIds : sg - 086 f61ea73388fb6b deploymentType : PERSISTENT_1 kmsKeyId : < kms_arn > You can then create persistent volume claim (see an example in FSx repo ) and use within your spark application as below --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.options.claimName=fsx-claim --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.readOnly=false --conf spark.kubernetes.driver.volumes.persistentVolumeClaim.data.mount.path=/data","title":"Amazon FSx for Lustre"},{"location":"security/docs/spark/encryption/#using-spark-to-encrypt-data","text":"Apache Spark supports encrypting temporary data that is stored on storage volumes. These volumes can be instance storage such as NVMe SSD volumes , EBS, EFS or FSx volumes. Temporary data can be shuffle files, shuffle spills and data blocks stored on disk (for both caching and broadcast variables). Its important to note that the data on NVMe instance storage is encrypted using an XTS-AES-256 block cipher implemented in a hardware module on the instance. Even though, instance storage is available, you need to format and mount them while you bootstrap EC2 instances. Below is an example to show how to use instance storage using eksctl managedNodeGroups: - name: nvme minSize: 2 desiredCapacity: 2 maxSize: 10 instanceType: r5d.4xlarge ssh: enableSsm: true preBootstrapCommands: - IDX=1 - for DEV in /dev/disk/by-id/nvme-Amazon_EC2_NVMe_Instance_Storage_*-ns-1; do mkfs.xfs ${ DEV } ;mkdir -p /local ${ IDX } ;echo ${ DEV } /local ${ IDX } xfs defaults,noatime 1 2 >> /etc/fstab; IDX=$(( ${ IDX } + 1)); done - mount -a If you use non-NVMe SSD volumes, you can follow the best practice to encrypt shuffle data before you write them to disks. You can see an example below that shows this example. For more information about the type of instance store volume supported by each instance type, see Instance store volumes . --conf spark.io.encryption.enabled=true","title":"Using Spark to encrypt data"},{"location":"security/docs/spark/encryption/#conclusion","text":"In this document, we covered shared responsibility model for running EMR on EKS workload. We then reviewed platform capabilities available through AWS infrastructure and how to enable encryption for both storage-level and via spark application. To quote Werner Vogels, AWS CTO \u201cSecurity is everyone\u2019s job now, not just the security team\u2019s\u201d. We hope this document provides prescriptive guidance into how to enable encryption for running secure EMR on EKS workload.","title":"Conclusion"},{"location":"security/docs/spark/network-security/","text":"","title":"Network security"},{"location":"spot-instances-resiliency/docs/","text":"","title":"Index"},{"location":"spot-instances-resiliency/docs/copying-shuffle-data/","text":"Spot instances interruption resiliency by copying shuffle data \u00b6 Amazon EC2 Spot Instances allow AWS customers to run EC2 instances at steep discounts by tapping into EC2 spare capacity pools. Using Amazon EKS\u2019s managed node groups, EKS can provision and manage the underlying Spot Instances (worker nodes) that provide compute capacity to EKS clusters. Using an EKS cluster with Spot instances to run EMR on EKS jobs allows customers to provision and maintain the desired capacity while benefiting from steep cost savings. However, Spot Instances can be interrupted with a two-minute notification when EC2 needs the capacity back. Termination of the Spot instance will result in termination of the executors on the node. The shuffle data and cached RDD data on these nodes will be lost and may need to be recalculated. This operation is very costly and will result in a high increase in the execution time of EMR on EKS jobs. This section shows how to use a new Apache Spark feature that allows you to store the shuffle data and cached RDD blocks present on the terminating executors to peer executors before a Spot node gets decommissioned. Consequently, your job does not need to recalculate the shuffle and RDD blocks of the terminating executor that would otherwise be lost, thus allowing the job to have minimal delay in completion. This feature is supported for releases EMR 6.3.0+. How does it work? \u00b6 When spark.decommission.enabled is true, Spark will try its best to shutdown the executor gracefully. spark.storage.decommission.enabled will enable migrating data stored on the executor. Spark will try to migrate all the cached RDD blocks (controlled by spark.storage.decommission.rddBlocks.enabled ) and shuffle blocks ( controlled by spark.storage.decommission.shuffleBlocks.enabled ) from the decommissioning executor to all remote executors when spark decommission is enabled. Relevant Spark configurations for using node decommissioning in the jobs are Configuration Description Default Value spark.decommission.enabled Whether to enable decommissioning false spark.storage.decommission.enabled Whether to decommission the block manager when decommissioning executor false spark.storage.decommission.rddBlocks.enabled Whether to transfer RDD blocks during block manager decommissioning. false spark.storage.decommission.shuffleBlocks.enabled Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle) false spark.storage.decommission.maxReplicationFailuresPerBlock Maximum number of failures which can be handled for migrating shuffle blocks when block manager is decommissioning and trying to move its existing blocks. 3 spark.storage.decommission.shuffleBlocks.maxThreads Maximum number of threads to use in migrating shuffle files. 8 This feature can currently be enabled through a temporary workaround on EMR 6.3.0+ releases. To enable it, Spark\u2019s decom.sh file permission must be modified using a custom image . Once the code is fixed, the page will be updated. Dockerfile for custom image: FROM < release account id > . dkr . ecr . < aws region > . amazonaws . com / spark /< release > USER root WORKDIR / home / hadoop RUN chown hadoop: hadoop / usr / bin / decom . sh Setting decommission timeout: Each executor has to be decommissioned within a certain time limit controlled by the pod\u2019s terminationGracePeriodSeconds configuration. The default value is 30 secs but can be modified using a custom pod template . The pod template for this modification would look like apiVersion : v1 kind : Pod spec : terminationGracePeriodSeconds : < seconds > Note: terminationGracePeriodSeconds timeout should be lesser than spot instance timeout with around 5 seconds buffer kept aside for triggering the node termination Request: cat > spark - python - with - node - decommissioning . json << EOF { \"name\" : \"my-job-run-with-node-decommissioning\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.3.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.container.image\" : \"<account_id>.dkr.ecr.<region>.amazonaws.com/<custom_image_repo>\" , \"spark.executor.instances\" : \"5\" , \"spark.decommission.enabled\" : \"true\" , \"spark.storage.decommission.rddBlocks.enabled\" : \"true\" , \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\" , \"spark.storage.decommission.enabled\" : \"true\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"<log group>\" , \"logStreamNamePrefix\" : \"<log-group-prefix>\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"<S3 URI>\" } } } } EOF Observed Behavior: When executors begin decommissioning, its shuffle data gets migrated to peer executors instead of recalculating the shuffle blocks again. If sending shuffle blocks to an executor fails, spark.storage.decommission.maxReplicationFailuresPerBlock will give the number of retries for migration. The driver log\u2019s stderr will see log lines Updating map output for <shuffle_id> to BlockManagerId(<executor_id>, <ip_address>, <port>, <topology_info>) denoting details about shuffle block \u2018s migration. This feature does not emit any other metrics for validation as of yet. Node decommissioning with fallback storage Spark supports a fallback storage configuration (spark.storage.decommission.fallbackStorage.path) and it can be used if migrating shuffle blocks to peer executors fails. However, there is an existing issue in Spark where these blocks cannot be read from the fallback path properly and a job fails with exception java.io.IOException: Stream is corrupted, net.jpountz.lz4.LZ4Exception: Error decoding offset <offset_id> of input buffer .","title":"Copying Shuffle data"},{"location":"spot-instances-resiliency/docs/copying-shuffle-data/#spot-instances-interruption-resiliency-by-copying-shuffle-data","text":"Amazon EC2 Spot Instances allow AWS customers to run EC2 instances at steep discounts by tapping into EC2 spare capacity pools. Using Amazon EKS\u2019s managed node groups, EKS can provision and manage the underlying Spot Instances (worker nodes) that provide compute capacity to EKS clusters. Using an EKS cluster with Spot instances to run EMR on EKS jobs allows customers to provision and maintain the desired capacity while benefiting from steep cost savings. However, Spot Instances can be interrupted with a two-minute notification when EC2 needs the capacity back. Termination of the Spot instance will result in termination of the executors on the node. The shuffle data and cached RDD data on these nodes will be lost and may need to be recalculated. This operation is very costly and will result in a high increase in the execution time of EMR on EKS jobs. This section shows how to use a new Apache Spark feature that allows you to store the shuffle data and cached RDD blocks present on the terminating executors to peer executors before a Spot node gets decommissioned. Consequently, your job does not need to recalculate the shuffle and RDD blocks of the terminating executor that would otherwise be lost, thus allowing the job to have minimal delay in completion. This feature is supported for releases EMR 6.3.0+.","title":"Spot instances interruption resiliency by copying shuffle data"},{"location":"spot-instances-resiliency/docs/copying-shuffle-data/#how-does-it-work","text":"When spark.decommission.enabled is true, Spark will try its best to shutdown the executor gracefully. spark.storage.decommission.enabled will enable migrating data stored on the executor. Spark will try to migrate all the cached RDD blocks (controlled by spark.storage.decommission.rddBlocks.enabled ) and shuffle blocks ( controlled by spark.storage.decommission.shuffleBlocks.enabled ) from the decommissioning executor to all remote executors when spark decommission is enabled. Relevant Spark configurations for using node decommissioning in the jobs are Configuration Description Default Value spark.decommission.enabled Whether to enable decommissioning false spark.storage.decommission.enabled Whether to decommission the block manager when decommissioning executor false spark.storage.decommission.rddBlocks.enabled Whether to transfer RDD blocks during block manager decommissioning. false spark.storage.decommission.shuffleBlocks.enabled Whether to transfer shuffle blocks during block manager decommissioning. Requires a migratable shuffle resolver (like sort based shuffle) false spark.storage.decommission.maxReplicationFailuresPerBlock Maximum number of failures which can be handled for migrating shuffle blocks when block manager is decommissioning and trying to move its existing blocks. 3 spark.storage.decommission.shuffleBlocks.maxThreads Maximum number of threads to use in migrating shuffle files. 8 This feature can currently be enabled through a temporary workaround on EMR 6.3.0+ releases. To enable it, Spark\u2019s decom.sh file permission must be modified using a custom image . Once the code is fixed, the page will be updated. Dockerfile for custom image: FROM < release account id > . dkr . ecr . < aws region > . amazonaws . com / spark /< release > USER root WORKDIR / home / hadoop RUN chown hadoop: hadoop / usr / bin / decom . sh Setting decommission timeout: Each executor has to be decommissioned within a certain time limit controlled by the pod\u2019s terminationGracePeriodSeconds configuration. The default value is 30 secs but can be modified using a custom pod template . The pod template for this modification would look like apiVersion : v1 kind : Pod spec : terminationGracePeriodSeconds : < seconds > Note: terminationGracePeriodSeconds timeout should be lesser than spot instance timeout with around 5 seconds buffer kept aside for triggering the node termination Request: cat > spark - python - with - node - decommissioning . json << EOF { \"name\" : \"my-job-run-with-node-decommissioning\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.3.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.container.image\" : \"<account_id>.dkr.ecr.<region>.amazonaws.com/<custom_image_repo>\" , \"spark.executor.instances\" : \"5\" , \"spark.decommission.enabled\" : \"true\" , \"spark.storage.decommission.rddBlocks.enabled\" : \"true\" , \"spark.storage.decommission.shuffleBlocks.enabled\" : \"true\" , \"spark.storage.decommission.enabled\" : \"true\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"<log group>\" , \"logStreamNamePrefix\" : \"<log-group-prefix>\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"<S3 URI>\" } } } } EOF Observed Behavior: When executors begin decommissioning, its shuffle data gets migrated to peer executors instead of recalculating the shuffle blocks again. If sending shuffle blocks to an executor fails, spark.storage.decommission.maxReplicationFailuresPerBlock will give the number of retries for migration. The driver log\u2019s stderr will see log lines Updating map output for <shuffle_id> to BlockManagerId(<executor_id>, <ip_address>, <port>, <topology_info>) denoting details about shuffle block \u2018s migration. This feature does not emit any other metrics for validation as of yet. Node decommissioning with fallback storage Spark supports a fallback storage configuration (spark.storage.decommission.fallbackStorage.path) and it can be used if migrating shuffle blocks to peer executors fails. However, there is an existing issue in Spark where these blocks cannot be read from the fallback path properly and a job fails with exception java.io.IOException: Stream is corrupted, net.jpountz.lz4.LZ4Exception: Error decoding offset <offset_id> of input buffer .","title":"How does it work?"},{"location":"storage/docs/","text":"","title":"Index"},{"location":"storage/docs/spark/ebs/","text":"Mount EBS Volume to spark driver and executor pods \u00b6 Amazon EBS volumes can be mounted on Spark driver and executor pods through static and dynamic provisioning. EKS support for EBS CSI driver Documentation for EBS CSI driver Static Provisioning \u00b6 Static Provisioning \u00b6 EKS Admin Tasks \u00b6 First, create your EBS volumes: aws ec2 -- region < region > create - volume -- availability - zone < availability zone > -- size 50 { \"AvailabilityZone\" : \"<availability zone>\" , \"MultiAttachEnabled\" : false , \"Tags\" : [], \"Encrypted\" : false , \"VolumeType\" : \"gp2\" , \"VolumeId\" : \"<vol -id>\" , \"State\" : \"creating\" , \"Iops\" : 150 , \"SnapshotId\" : \"\" , \"CreateTime\" : \"2020-11-03T18:36:21.000Z\" , \"Size\" : 50 } Create Persistent Volume(PV) that has the EBS volume created above hardcoded: cat > ebs-static-pv.yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: ebs-static-pv spec: capacity: storage: 5Gi accessModes: - ReadWriteOnce storageClassName: gp2 awsElasticBlockStore: fsType: ext4 volumeID: <vol -id> EOF kubectl apply -f ebs-static-pv.yaml -n <namespace> Create Persistent Volume Claim(PVC) for the Persistent Volume created above: cat > ebs-static-pvc.yaml << EOF kind: PersistentVolumeClaim apiVersion: v1 metadata: name: ebs-static-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi volumeName: ebs-static-pv EOF kubectl apply -f ebs-static-pvc.yaml -n <namespace> PVC - ebs-static-pvc can be used by spark developer to mount to the spark pod NOTE : Pods running in EKS worker nodes can only attach to the EBS volume provisioned in the same AZ as the EKS worker node. Use node selectors to schedule pods on EKS worker nodes the specified AZ. Spark Developer Tasks \u00b6 Request cat > spark - python - in - s3 - ebs - static - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-static-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-static-pvc\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - static - localdir . json Observed Behavior: When the job gets started, the pre-provisioned EBS volume is mounted to driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also you can verify the mount from the driver pod's spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export Dynamic Provisioning \u00b6 EKS Admin Tasks \u00b6 Create EBS Storage Class cat >demo-gp2-sc.yaml << EOF apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: demo-gp2-sc provisioner: kubernetes.io/aws-ebs parameters: type: gp2 reclaimPolicy: Retain allowVolumeExpansion: true mountOptions: - debug volumeBindingMode: Immediate EOF kubectl apply -f demo-gp2-sc.yaml create Persistent Volume for the EBS storage class - demo-gp2-sc cat >ebs-demo-gp2-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: ebs-demo-gp2-claim labels: app: chicago spec: storageClassName: demo-gp2-sc accessModes: - ReadWriteOnce resources: requests: storage: 100Gi EOF kubectl apply -f ebs-demo-gp2-claim.yaml -n <namespace> Spark Developer Tasks \u00b6 Request cat > spark - python - in - s3 - ebs - dynamic - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-dynamic-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-demo-gp2-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - dynamic - localdir . json Observed Behavior: When the job gets started an EBS volume is provisioned dynamically by the EBS CSI driver and mounted to the driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also, you can verify the mount from driver pod spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export POINT TO NOTE : It is not possible to use this dynamic provisioning strategy for EBS to spark executors. It is not possible to mount a new EBS volume to every Spark executor. Instead use a distributed file system like Lustre, EFS, NFS to mount to executors.","title":"EBS"},{"location":"storage/docs/spark/ebs/#mount-ebs-volume-to-spark-driver-and-executor-pods","text":"Amazon EBS volumes can be mounted on Spark driver and executor pods through static and dynamic provisioning. EKS support for EBS CSI driver Documentation for EBS CSI driver","title":"Mount EBS Volume to spark driver and executor pods"},{"location":"storage/docs/spark/ebs/#static-provisioning","text":"","title":"Static Provisioning"},{"location":"storage/docs/spark/ebs/#static-provisioning_1","text":"","title":"Static Provisioning"},{"location":"storage/docs/spark/ebs/#eks-admin-tasks","text":"First, create your EBS volumes: aws ec2 -- region < region > create - volume -- availability - zone < availability zone > -- size 50 { \"AvailabilityZone\" : \"<availability zone>\" , \"MultiAttachEnabled\" : false , \"Tags\" : [], \"Encrypted\" : false , \"VolumeType\" : \"gp2\" , \"VolumeId\" : \"<vol -id>\" , \"State\" : \"creating\" , \"Iops\" : 150 , \"SnapshotId\" : \"\" , \"CreateTime\" : \"2020-11-03T18:36:21.000Z\" , \"Size\" : 50 } Create Persistent Volume(PV) that has the EBS volume created above hardcoded: cat > ebs-static-pv.yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: ebs-static-pv spec: capacity: storage: 5Gi accessModes: - ReadWriteOnce storageClassName: gp2 awsElasticBlockStore: fsType: ext4 volumeID: <vol -id> EOF kubectl apply -f ebs-static-pv.yaml -n <namespace> Create Persistent Volume Claim(PVC) for the Persistent Volume created above: cat > ebs-static-pvc.yaml << EOF kind: PersistentVolumeClaim apiVersion: v1 metadata: name: ebs-static-pvc spec: accessModes: - ReadWriteOnce resources: requests: storage: 5Gi volumeName: ebs-static-pv EOF kubectl apply -f ebs-static-pvc.yaml -n <namespace> PVC - ebs-static-pvc can be used by spark developer to mount to the spark pod NOTE : Pods running in EKS worker nodes can only attach to the EBS volume provisioned in the same AZ as the EKS worker node. Use node selectors to schedule pods on EKS worker nodes the specified AZ.","title":"EKS Admin Tasks"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks","text":"Request cat > spark - python - in - s3 - ebs - static - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-static-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 \" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-static-pvc\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - static - localdir . json Observed Behavior: When the job gets started, the pre-provisioned EBS volume is mounted to driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also you can verify the mount from the driver pod's spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/ebs/#dynamic-provisioning","text":"","title":"Dynamic Provisioning"},{"location":"storage/docs/spark/ebs/#eks-admin-tasks_1","text":"Create EBS Storage Class cat >demo-gp2-sc.yaml << EOF apiVersion: storage.k8s.io/v1 kind: StorageClass metadata: name: demo-gp2-sc provisioner: kubernetes.io/aws-ebs parameters: type: gp2 reclaimPolicy: Retain allowVolumeExpansion: true mountOptions: - debug volumeBindingMode: Immediate EOF kubectl apply -f demo-gp2-sc.yaml create Persistent Volume for the EBS storage class - demo-gp2-sc cat >ebs-demo-gp2-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: ebs-demo-gp2-claim labels: app: chicago spec: storageClassName: demo-gp2-sc accessModes: - ReadWriteOnce resources: requests: storage: 100Gi EOF kubectl apply -f ebs-demo-gp2-claim.yaml -n <namespace>","title":"EKS Admin Tasks"},{"location":"storage/docs/spark/ebs/#spark-developer-tasks_1","text":"Request cat > spark - python - in - s3 - ebs - dynamic - localdir . json << EOF { \"name\" : \"spark-python-in-s3-ebs-dynamic-localdir\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.instances=10 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.options.claimName\" : \"ebs-demo-gp2-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.spark-local-dir-sparkspill.mount.readOnly\" : \"false\" , } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// spark - python - in - s3 - ebs - dynamic - localdir . json Observed Behavior: When the job gets started an EBS volume is provisioned dynamically by the EBS CSI driver and mounted to the driver pod. You can exec into the driver container to verify that the EBS volume is mounted. Also, you can verify the mount from driver pod spec. kubectl get pod < driver pod name > - n < namespace > - o yaml -- export POINT TO NOTE : It is not possible to use this dynamic provisioning strategy for EBS to spark executors. It is not possible to mount a new EBS volume to every Spark executor. Instead use a distributed file system like Lustre, EFS, NFS to mount to executors.","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/fsx-lustre/","text":"EMR Containers integration with FSx for Lustre \u00b6 Amazon EKS clusters provide the compute and ephemeral storage for Spark workloads. Ephemeral storage provided by EKS is allocated from the EKS worker node's disk storage and the lifecycle of the storage is bound by the lifecycle of the driver and executor pod. Need for durable storage: When multiple spark applications are executed as part of a data pipeline, there are scenarios where data from one spark application is passed to subsequent spark applications - in this case data can be persisted in S3. Alternatively, this data can also be persisted in FSx for Lustre . FSx for Lustre provides a fully managed, scalable, POSIX compliant native filesystem interface for the data in s3. With FSx, your torage is decoupled from your compute and has its own lifecycle. FSx for Lustre Volumes can be mounted on spark driver and executor pods through static and dynamic provisioning. Data used in the below example is from AWS Open data Registry FSx for Lustre POSIX permissions \u00b6 When a Lustre filesystem is mounted to driver and executor pods, and if the S3 objects does not have required metadata, the mounted volume defaults ownership of the file system to root . EMR on EKS executes the driver and executor pods with UID(999), GID (1000) and groups(1000 and 65534). In this scenario, the spark application has read only access to the mounted Lustre file system. Below are a few approaches that can be considered: Tag Metadata to S3 object \u00b6 Applications writing to S3 can tag the S3 objects with the metadata that FSx for Lustre requires. Walkthrough: Attaching POSIX permissions when uploading objects into an S3 bucket provides a guided tutorial. FSx for Lustre will convert this tagged metadata to corresponding POSIX permissions when mounting Lustre file system to the driver and executor pods. EMR on EKS spawns the driver and executor pods as non-root user( UID -999, GID - 1000, groups - 1000, 65534 ). To enable the spark application to write to the mounted file system, (UID - 999 ) can be made as the file-owner and supplemental group 65534 be made as the file-group . For S3 objects that already exists with no metadata tagging, there can be a process that recursively tags all the S3 objects with the required metadata. Below is an example: 1. Create FSx for Lustre file system to the S3 prefix. 2. Create Persistent Volume and Persistent Volume claim for the created FSx for Lustre file system 3. Run a pod as root user with FSx for Lustre mounted with the PVC created in Step 2. ``` apiVersion: v1 kind: Pod metadata: name: chmod-fsx-pod namespace: test-demo spec: containers: - name: ownership-change image: amazonlinux:2 command: [\"sh\", \"-c\", \"chown -hR +999:+65534 /data\"] volumeMounts: - name: persistent-storage mountPath: /data volumes: - name: persistent-storage persistentVolumeClaim: claimName: fsx-static-root-claim ``` Run a data repository task with import path and export path pointing to the same S3 prefix. This will export the POSIX permission from FSx for Lustre file system as metadata, that is tagged on S3 objects. Now that the S3 objects are tagged with metadata, the spark application with FSx for Lustre filesystem mounted will have write access. Static Provisioning \u00b6 Provision a FSx for Lustre cluster \u00b6 FSx for Luster can also be provisioned through aws cli How to decide what type of FSx for Lustre file system you need ? Create a Security Group to attach to FSx for Lustre file system as below Points to Note: Security group attached to the EKS worker nodes is given access on port number 988, 1021-1023 in inbound rules. Security group specified when creating the FSx for Lustre filesystem is given access on port number 988, 1021-1023 in inbound rules. Fsx for Lustre Provisioning through aws cli cat fsxLustreConfig.json << EOF { \"ClientRequestToken\": \"EMRContainers-fsxLustre-demo\", \"FileSystemType\": \"LUSTRE\", \"StorageCapacity\": 1200, \"StorageType\": \"SSD\", \"SubnetIds\": [ \"<subnet-id>\" ], \"SecurityGroupIds\": [ \"<securitygroup-id>\" ], \"LustreConfiguration\": { \"ImportPath\": \"s3://<s3 prefix>/\", \"ExportPath\": \"s3://<s3 prefix>/\", \"DeploymentType\": \"PERSISTENT_1\", \"AutoImportPolicy\": \"NEW_CHANGED\", \"PerUnitStorageThroughput\": 200 } } EOF Run the aws-cli command to create the FSx for Lustre filesystem as below. aws fsx create-file-system --cli-input-json file:///fsxLustreConfig.json Response is as below { \"FileSystem\" : { \"VpcId\" : \"<vpc id>\" , \"Tags\" : [], \"StorageType\" : \"SSD\" , \"SubnetIds\" : [ \"<subnet-id>\" ], \"FileSystemType\" : \"LUSTRE\" , \"CreationTime\" : 1603752401.183 , \"ResourceARN\" : \"<fsx resource arn>\" , \"StorageCapacity\" : 1200 , \"LustreConfiguration\" : { \"CopyTagsToBackups\" : false , \"WeeklyMaintenanceStartTime\" : \"7:11:30\" , \"DataRepositoryConfiguration\" : { \"ImportPath\" : \"s3://<s3 prefix>\" , \"AutoImportPolicy\" : \"NEW_CHANGED\" , \"ImportedFileChunkSize\" : 1024 , \"Lifecycle\" : \"CREATING\" , \"ExportPath\" : \"s3://<s3 prefix>/\" }, \"DeploymentType\" : \"PERSISTENT_1\" , \"PerUnitStorageThroughput\" : 200 , \"MountName\" : \"mvmxtbmv\" }, \"FileSystemId\" : \"<filesystem id>\" , \"DNSName\" : \"<filesystem id>.fsx.<region>.amazonaws.com\" , \"KmsKeyId\" : \"arn:aws:kms:<region>:<account>:key/<key id>\" , \"OwnerId\" : \"<account>\" , \"Lifecycle\" : \"CREATING\" } } EKS admin tasks \u00b6 Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume and Persistent Volume Claim for FSx for Lustre FSx for Lustre file system is created as described above - Provision a FSx for Lustre cluster Once provisioned, a persistent volume - as specified below is created with a direct (hard-coded) reference to the created lustre file system. A Persistent Volume claim for this persistent volume will always use the same file system. cat > fsxLustre - static - pv . yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: fsx - pv spec: capacity: storage: 1200 Gi volumeMode: Filesystem accessModes: - ReadWriteMany mountOptions: - flock persistentVolumeReclaimPolicy: Recycle csi: driver: fsx . csi . aws . com volumeHandle: < filesystem id > volumeAttributes: dnsname: < filesystem id > . fsx . < region > . amazonaws . com mountname: mvmxtbmv EOF kubectl apply -f fsxLustre-static-pv.yaml Now, a Persistent Volume Claim (PVC) needs to be created that references PV created above. cat >fsxLustre-static-pvc.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-claim namespace: ns1 spec: accessModes: - ReadWriteMany storageClassName: \"\" resources: requests: storage: 1200Gi volumeName: fsx-pv EOF kubectl apply - f fsxLustre - static - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster > Spark Developer Tasks \u00b6 Now spark applications can use fsx-claim in their spark application config to mount the FSx for Lustre filesystem to driver and executor container volumes. cat > spark - python - in - s3 - fsx . json << EOF { \"name\" : \"spark-python-in-s3-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx.json Expected Behavior: All spark jobs that are run with persistent volume claims as fsx-claim will mount to the statically created FSx for Lustre file system. Use case: A data pipeline consisting of 10 spark applications can all be mounted to the statically created FSx for Lustre file system and can write the intermediate output to a particular folder. The next spark job in the data pipeline that is dependent on this data can read from FSx for Lustre. Data that needs to be persisted beyond the scope of the data pipeline can be exported to S3 by creating data repository tasks Data that is used often by multiple spark applications can also be stored in FSx for Lustre for improved performance. Dynamic Provisioning \u00b6 A FSx for Lustre file system can be provisioned on-demand. A Storage-class resource is created and that provisions FSx for Lustre file system dynamically. A PVC is created and refers to the storage class resource that was created. Whenever a pod refers to the PVC, the storage class invokes the FSx for Lustre Container Storage Interface (CSI) to provision a Lustre file system on the fly dynamically. In this model, FSx for Lustre of type Scratch File Systems is provisioned. EKS Admin Tasks \u00b6 Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume Claim( fsx-dynamic-claim ) for FSx for Lustre. Create PVC for dynamic provisioning with fsx-sc storage class. cat >fsx-dynamic-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-dynamic-claim spec: accessModes: - ReadWriteMany storageClassName: fsx-sc resources: requests: storage: 3600Gi EOF kubectl apply - f fsx - dynamic - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster > Spark Developer Tasks \u00b6 cat > spark - python - in - s3 - fsx - dynamic . json << EOF { \"name\" : \"spark-python-in-s3-fsx-dynamic\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.local.dir\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName\" : \"fsx-dynamic-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx-dynamic.json Expected Result: Statically provisioned FSx for Lustre is mounted to /var/data/ as before for the driver pod. For all the executors a SCRATCH 1 deployment type FSx for Lustre is provisioned on the fly dynamically by the Storage class that was created. There will be a latency before the first executor can start running - because the Lustre has to be created. Once it is created the same Lustre file system is mounted to all the executors. Also note - \"spark.local.dir\":\"/var/spark/spill/\" is used to force executor to use this folder mounted to Lustre for all spill and shuffle data. Once the spark job is completed, the Lustre file system is deleted or retained based on the PVC configuration. This dynamically created Lustre file system is mapped to a S3 path like the statically created filesystem. FSx-csi user guide","title":"FSx for Lustre"},{"location":"storage/docs/spark/fsx-lustre/#emr-containers-integration-with-fsx-for-lustre","text":"Amazon EKS clusters provide the compute and ephemeral storage for Spark workloads. Ephemeral storage provided by EKS is allocated from the EKS worker node's disk storage and the lifecycle of the storage is bound by the lifecycle of the driver and executor pod. Need for durable storage: When multiple spark applications are executed as part of a data pipeline, there are scenarios where data from one spark application is passed to subsequent spark applications - in this case data can be persisted in S3. Alternatively, this data can also be persisted in FSx for Lustre . FSx for Lustre provides a fully managed, scalable, POSIX compliant native filesystem interface for the data in s3. With FSx, your torage is decoupled from your compute and has its own lifecycle. FSx for Lustre Volumes can be mounted on spark driver and executor pods through static and dynamic provisioning. Data used in the below example is from AWS Open data Registry","title":"EMR Containers integration with FSx for Lustre"},{"location":"storage/docs/spark/fsx-lustre/#fsx-for-lustre-posix-permissions","text":"When a Lustre filesystem is mounted to driver and executor pods, and if the S3 objects does not have required metadata, the mounted volume defaults ownership of the file system to root . EMR on EKS executes the driver and executor pods with UID(999), GID (1000) and groups(1000 and 65534). In this scenario, the spark application has read only access to the mounted Lustre file system. Below are a few approaches that can be considered:","title":"FSx for Lustre POSIX permissions"},{"location":"storage/docs/spark/fsx-lustre/#tag-metadata-to-s3-object","text":"Applications writing to S3 can tag the S3 objects with the metadata that FSx for Lustre requires. Walkthrough: Attaching POSIX permissions when uploading objects into an S3 bucket provides a guided tutorial. FSx for Lustre will convert this tagged metadata to corresponding POSIX permissions when mounting Lustre file system to the driver and executor pods. EMR on EKS spawns the driver and executor pods as non-root user( UID -999, GID - 1000, groups - 1000, 65534 ). To enable the spark application to write to the mounted file system, (UID - 999 ) can be made as the file-owner and supplemental group 65534 be made as the file-group . For S3 objects that already exists with no metadata tagging, there can be a process that recursively tags all the S3 objects with the required metadata. Below is an example: 1. Create FSx for Lustre file system to the S3 prefix. 2. Create Persistent Volume and Persistent Volume claim for the created FSx for Lustre file system 3. Run a pod as root user with FSx for Lustre mounted with the PVC created in Step 2. ``` apiVersion: v1 kind: Pod metadata: name: chmod-fsx-pod namespace: test-demo spec: containers: - name: ownership-change image: amazonlinux:2 command: [\"sh\", \"-c\", \"chown -hR +999:+65534 /data\"] volumeMounts: - name: persistent-storage mountPath: /data volumes: - name: persistent-storage persistentVolumeClaim: claimName: fsx-static-root-claim ``` Run a data repository task with import path and export path pointing to the same S3 prefix. This will export the POSIX permission from FSx for Lustre file system as metadata, that is tagged on S3 objects. Now that the S3 objects are tagged with metadata, the spark application with FSx for Lustre filesystem mounted will have write access.","title":"Tag Metadata to S3 object"},{"location":"storage/docs/spark/fsx-lustre/#static-provisioning","text":"","title":"Static Provisioning"},{"location":"storage/docs/spark/fsx-lustre/#provision-a-fsx-for-lustre-cluster","text":"FSx for Luster can also be provisioned through aws cli How to decide what type of FSx for Lustre file system you need ? Create a Security Group to attach to FSx for Lustre file system as below Points to Note: Security group attached to the EKS worker nodes is given access on port number 988, 1021-1023 in inbound rules. Security group specified when creating the FSx for Lustre filesystem is given access on port number 988, 1021-1023 in inbound rules. Fsx for Lustre Provisioning through aws cli cat fsxLustreConfig.json << EOF { \"ClientRequestToken\": \"EMRContainers-fsxLustre-demo\", \"FileSystemType\": \"LUSTRE\", \"StorageCapacity\": 1200, \"StorageType\": \"SSD\", \"SubnetIds\": [ \"<subnet-id>\" ], \"SecurityGroupIds\": [ \"<securitygroup-id>\" ], \"LustreConfiguration\": { \"ImportPath\": \"s3://<s3 prefix>/\", \"ExportPath\": \"s3://<s3 prefix>/\", \"DeploymentType\": \"PERSISTENT_1\", \"AutoImportPolicy\": \"NEW_CHANGED\", \"PerUnitStorageThroughput\": 200 } } EOF Run the aws-cli command to create the FSx for Lustre filesystem as below. aws fsx create-file-system --cli-input-json file:///fsxLustreConfig.json Response is as below { \"FileSystem\" : { \"VpcId\" : \"<vpc id>\" , \"Tags\" : [], \"StorageType\" : \"SSD\" , \"SubnetIds\" : [ \"<subnet-id>\" ], \"FileSystemType\" : \"LUSTRE\" , \"CreationTime\" : 1603752401.183 , \"ResourceARN\" : \"<fsx resource arn>\" , \"StorageCapacity\" : 1200 , \"LustreConfiguration\" : { \"CopyTagsToBackups\" : false , \"WeeklyMaintenanceStartTime\" : \"7:11:30\" , \"DataRepositoryConfiguration\" : { \"ImportPath\" : \"s3://<s3 prefix>\" , \"AutoImportPolicy\" : \"NEW_CHANGED\" , \"ImportedFileChunkSize\" : 1024 , \"Lifecycle\" : \"CREATING\" , \"ExportPath\" : \"s3://<s3 prefix>/\" }, \"DeploymentType\" : \"PERSISTENT_1\" , \"PerUnitStorageThroughput\" : 200 , \"MountName\" : \"mvmxtbmv\" }, \"FileSystemId\" : \"<filesystem id>\" , \"DNSName\" : \"<filesystem id>.fsx.<region>.amazonaws.com\" , \"KmsKeyId\" : \"arn:aws:kms:<region>:<account>:key/<key id>\" , \"OwnerId\" : \"<account>\" , \"Lifecycle\" : \"CREATING\" } }","title":"Provision a FSx for Lustre cluster"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks","text":"Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume and Persistent Volume Claim for FSx for Lustre FSx for Lustre file system is created as described above - Provision a FSx for Lustre cluster Once provisioned, a persistent volume - as specified below is created with a direct (hard-coded) reference to the created lustre file system. A Persistent Volume claim for this persistent volume will always use the same file system. cat > fsxLustre - static - pv . yaml << EOF apiVersion: v1 kind: PersistentVolume metadata: name: fsx - pv spec: capacity: storage: 1200 Gi volumeMode: Filesystem accessModes: - ReadWriteMany mountOptions: - flock persistentVolumeReclaimPolicy: Recycle csi: driver: fsx . csi . aws . com volumeHandle: < filesystem id > volumeAttributes: dnsname: < filesystem id > . fsx . < region > . amazonaws . com mountname: mvmxtbmv EOF kubectl apply -f fsxLustre-static-pv.yaml Now, a Persistent Volume Claim (PVC) needs to be created that references PV created above. cat >fsxLustre-static-pvc.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-claim namespace: ns1 spec: accessModes: - ReadWriteMany storageClassName: \"\" resources: requests: storage: 1200Gi volumeName: fsx-pv EOF kubectl apply - f fsxLustre - static - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster >","title":"EKS admin tasks"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks","text":"Now spark applications can use fsx-claim in their spark application config to mount the FSx for Lustre filesystem to driver and executor container volumes. cat > spark - python - in - s3 - fsx . json << EOF { \"name\" : \"spark-python-in-s3-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx.json Expected Behavior: All spark jobs that are run with persistent volume claims as fsx-claim will mount to the statically created FSx for Lustre file system. Use case: A data pipeline consisting of 10 spark applications can all be mounted to the statically created FSx for Lustre file system and can write the intermediate output to a particular folder. The next spark job in the data pipeline that is dependent on this data can read from FSx for Lustre. Data that needs to be persisted beyond the scope of the data pipeline can be exported to S3 by creating data repository tasks Data that is used often by multiple spark applications can also be stored in FSx for Lustre for improved performance.","title":"Spark Developer Tasks"},{"location":"storage/docs/spark/fsx-lustre/#dynamic-provisioning","text":"A FSx for Lustre file system can be provisioned on-demand. A Storage-class resource is created and that provisions FSx for Lustre file system dynamically. A PVC is created and refers to the storage class resource that was created. Whenever a pod refers to the PVC, the storage class invokes the FSx for Lustre Container Storage Interface (CSI) to provision a Lustre file system on the fly dynamically. In this model, FSx for Lustre of type Scratch File Systems is provisioned.","title":"Dynamic Provisioning"},{"location":"storage/docs/spark/fsx-lustre/#eks-admin-tasks_1","text":"Attach IAM policy to EKS worker node IAM role to enable access to FSx for Lustre - Mount FSx for Lustre on EKS and Create a Security Group for FSx for Lustre Install the FSx CSI Driver in EKS Configure Storage Class for FSx for Lustre Configure Persistent Volume Claim( fsx-dynamic-claim ) for FSx for Lustre. Create PVC for dynamic provisioning with fsx-sc storage class. cat >fsx-dynamic-claim.yaml <<EOF apiVersion: v1 kind: PersistentVolumeClaim metadata: name: fsx-dynamic-claim spec: accessModes: - ReadWriteMany storageClassName: fsx-sc resources: requests: storage: 3600Gi EOF kubectl apply - f fsx - dynamic - pvc . yaml - n < namespace registered with EMR on EKS Virtual Cluster >","title":"EKS Admin Tasks"},{"location":"storage/docs/spark/fsx-lustre/#spark-developer-tasks_1","text":"cat > spark - python - in - s3 - fsx - dynamic . json << EOF { \"name\" : \"spark-python-in-s3-fsx-dynamic\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/trip-count-repartition-fsx.py\" , \"sparkSubmitParameters\" : \"--conf spark.driver.cores=5 --conf spark.kubernetes.pyspark.pythonVersion=3 --conf spark.executor.memory=20G --conf spark.driver.memory=15G --conf spark.executor.cores=6 --conf spark.sql.shuffle.partitions=1000\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.local.dir\" : \"/var/spark/spill/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.options.claimName\" : \"fsx-dynamic-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.path\" : \"/var/spark/spill/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.spark-local-dir-spill.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3-fsx-dynamic.json Expected Result: Statically provisioned FSx for Lustre is mounted to /var/data/ as before for the driver pod. For all the executors a SCRATCH 1 deployment type FSx for Lustre is provisioned on the fly dynamically by the Storage class that was created. There will be a latency before the first executor can start running - because the Lustre has to be created. Once it is created the same Lustre file system is mounted to all the executors. Also note - \"spark.local.dir\":\"/var/spark/spill/\" is used to force executor to use this folder mounted to Lustre for all spill and shuffle data. Once the spark job is completed, the Lustre file system is deleted or retained based on the PVC configuration. This dynamically created Lustre file system is mapped to a S3 path like the statically created filesystem. FSx-csi user guide","title":"Spark Developer Tasks"},{"location":"submit-applications/docs/spark/","text":"","title":"Index"},{"location":"submit-applications/docs/spark/java-and-scala/","text":"","title":"Java and scala"},{"location":"submit-applications/docs/spark/pyspark/","text":"Pyspark Job submission \u00b6 Python interpreter is bundled in the EMR containers spark image that is used to run the spark job.Python code and dependencies can be provided with the below options. Python code self contained in a single .py file \u00b6 To start with, in the most simplest scenario - the example below shows how to submit a pi.py file that is self contained and doesn't need any other dependencies. Python file from S3 \u00b6 Request pi.py used in the below request payload is from spark examples cat > spark-python-in-s3.json << EOF { \"name\": \"spark-python-in-image\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3.json Python file from mounted volume \u00b6 In the below example - pi.py is placed in a mounted volume. FSx for Lustre filesystem is mounted as a Persistent Volume on the driver pod under /var/data/ and will be referenced by local:// file prefix. For more information on how to mount FSx for lustre - EMR-Containers-integration-with-FSx-for-Lustre This approach can be used to provide spark application code and dependencies for execution. Persistent Volume mounted to the driver and executor pods lets you access the application code and dependencies with local:// prefix. cat > spark - python - in - FSx . json << EOF { \"name\" : \"spark-python-in-FSx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"local:///var/data/FSxLustre-pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - Fsx . json Python code with dependencies \u00b6 List of .py files \u00b6 This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. cat > py - files - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext import dependentFunc if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF cat > dependentFunc.py <<EOF def message(): print(\"Printing from inside the dependent python file\") EOF Upload dependentFunc.py and py-files-pi.py to s3 Request: cat > spark-python-in-s3-dependency-files << EOF { \"name\": \"spark-python-in-s3-dependency-files\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/dependentFunc.py --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-files.json Bundled as a zip file \u00b6 In this approach all the dependent python files are bundled as a zip file. Each folder should have __init__.py file as documented in zip python dependencies . Zip should be done at the top folder level and using the -r option. zip -r pyspark-packaged-dependency-src.zip . adding: dependent/ (stored 0%) adding: dependent/__init__.py (stored 0%) adding: dependent/dependentFunc.py (deflated 7%) dependentFunc.py from earlier example has been bundled as pyspark-packaged-dependency-src.zip . Upload this file to a S3 location cat > py - files - zip - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext ** from dependent import dependentFunc ** if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF Request: cat > spark-python-in-s3-dependency-zip.json <<EOF { \"name\": \"spark-python-in-s3-dependency-zip\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark-packaged-dependency-src.zip --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-zip.json Bundled as a .egg file \u00b6 Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .egg file cd / pyspark - packaged - example pip install setuptools python setup . py bdist_egg Upload dist/pyspark_packaged_example-0.0.3-py3.8.egg to a S3 location Request: cat > spark-python-in-s3-dependency-egg.json <<EOF { \"name\": \"spark-python-in-s3-dependency-egg\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3.8.egg --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-egg.json Bundled as a .whl file \u00b6 Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .whl file cd /pyspark-packaged-example `pip install wheel` python setup.py bdist_wheel Upload dist/pyspark_packaged_example-0.0.3-py3-none-any.whl to a s3 location Request: cat > spark-python-in-s3-dependency-wheel.json <<EOF { \"name\": \"spark-python-in-s3-dependency-wheel\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3-none-any.whl --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-wheel.json Bundled as a .pex file \u00b6 pex is a library for generating .pex (Python EXecutable) files which are executable Python environments.PEX files can be created as below docker run -it -v $(pwd):/workdir python:3.7.9-buster /bin/bash #python 3.7.9 is installed in EMR 6.1.0 pip3 install pex pex --python=python3 --inherit-path=prefer -v numpy -o numpy_dep.pex To read more about PEX: PEX PEX documentation Tips on PEX pex packaging for pyspark Approach 1: Using Persistent Volume - FSx for Lustre cluster Upload numpy_dep.pex to a s3 location that is mapped to a FSx for Lustre cluster. numpy_dep.pex can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod. Request: kmeans.py used in the below request is from spark examples cat > spark - python - in - s3 - pex - fsx . json << EOF { \"name\" : \"spark-python-in-s3-pex-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.kubernetes.driverEnv.PEX_ROOT\" : \"./tmp\" , \"spark.executorEnv.PEX_ROOT\" : \"./tmp\" , \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.executorEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.kubernetes.driverEnv.PEX_VERBOSE\" : \"10\" , \"spark.kubernetes.driverEnv.PEX_PYTHON\" : \"python3\" , \"spark.executorEnv.PEX_PYTHON\" : \"python3\" , \"spark.pyspark.driver.python\" : \"/var/data/numpy_dep.pex\" , \"spark.pyspark.python\" : \"/var/data/numpy_dep.pex\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } aws emr - containers start - job - run -- cli - input - json file : //// Spark - Python - in - s3 - pex - fsx . json Approach 2: Using Custom Pod Templates Upload numpy_dep.pex to a s3 location. Create custom pod templates for driver and executor pods. Custom pod templates allows running a command through initContainers before the main application container is created. In this case, the command will download the numpy_dep.pex file to the /tmp/numpy_dep.pex path of the driver and executor pods. Note: This approach is only supported for release image 5.33.0 and later or 6.3.0 and later. Sample driver pod template YAML file: cat > driver_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-driver initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Sample executor pod template YAML file: cat > executor_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-executor initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Replace initContainer's image with the respective release label's container image. In this case we are using the image of release emr-5.33.0-latest . Upload the driver and executor custom pod templates to S3 Request: kmeans.py used in the below request is from spark examples cat > spark-python-in-s3-pex-pod-templates.json << EOF { \"name\": \"spark-python-in-s3-pex-pod-templates\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-5.33.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/kmeans.py\", \"entryPointArguments\": [ \"s3://<s3 prefix>/kmeans_data.txt\", \"2\", \"3\" ], \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.pyspark.pythonVersion\":\"3\", \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\", \"spark.executorEnv.PEX_ROOT\":\"./tmp\", \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\", \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\", \"spark.executorEnv.PEX_PYTHON\":\"python3\", \"spark.pyspark.driver.python\":\"/tmp/numpy_dep.pex\", \"spark.pyspark.python\":\"/tmp/numpy_dep.pex\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<s3-prefix>/driver_pod_template.yaml\", \"spark.kubernetes.executor.podTemplateFile\": \"s3://<s3-prefix>/executor_pod_template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } aws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-pod-templates.json Point to Note: PEX files don\u2019t have the python interpreter bundled with it. Using the PEX env variables, we pass in the python interpreter installed in the spark driver and executor docker image. pex vs conda-pack A pex file contain only dependent Python packages but not a Python interpreter in it while a conda-pack environment has a Python interpreter as well, so with the same Python packages a conda-pack environment is much larger than a pex file. A conda-pack environment is a tar.gz file and need to be decompressed before being used while a pex file can be used directly. If a Python interpreter exists, pex is a better option than conda-pack. However, conda-pack is the ONLY CHOICE if you need a specific version of Python interpreter which does not exist and you do not have permission to install one (e.g., when you need to use a specific version of Python interpreter with an enterprise PySpark cluster). If the pex file or conda-pack environment needs to be distributed to machines on demand, there are some overhead before running your application. With the same Python packages, a conda-pack environment has large overhead/latency than the pex file as the conda-pack environment is usually much larger and need to be decompressed before being used. For more information - Tips on PEX Bundled as a tar.gz file with conda-pack \u00b6 conda-pack for spark Install conda through Miniconda Open a new terminal and execute the below commands conda create -y -n example python=3.5 numpy conda activate example pip install conda-pack conda pack -f -o numpy_environment.tar.gz Upload numpy_environment.tar.gz to a s3 location that is mapped to a FSx for Lustre cluster. numpy_environment.tar.gz can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod.Alternatively, S3 path for numpy_environment.tar.gz can also be passed using --py-files Request: { \"name\" : \"spark-python-in-s3-conda-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--verbose --archives /var/data/numpy_environment.tar.gz#environment --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.executor.instances\" : \"3\" , \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.files\" : \"/var/data/numpy_environment.tar.gz#environment\" , \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.pyspark.driver.python\" : \"./environment/bin/python\" , \"spark.pyspark.python\" : \"./environment/bin/python\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } The above request doesn't work with spark on kubernetes Bundled as virtual env \u00b6 This will not work with spark on kubernetes .This feature only works with YARN - cluster mode In this implementation for YARN - the dependencies will be installed from the repository for every driver and executor. This might not be a more scalable model as per SPARK-25433 . Recommended solution is to pass in the dependencies as PEX file. Import of Dynamic Modules (.pyd, .so) \u00b6 Import of dynamic modules(.pyd, .so) is disallowed when bundled as a zip Steps to create a .so file example.c /* File : example.c */ #include \"example.h\" unsigned int add ( unsigned int a , unsigned int b ) { printf ( \" \\n Inside add function in C library \\n \" ); return ( a + b ); } example.h /* File : example.h */ # include < stdio . h > extern unsigned int add ( unsigned int a , unsigned int b ) ; gcc -fPIC -Wall -g -c example.c gcc -shared -fPIC -o libexample.so example.o Upload libexample.so to a S3 location. pyspark code to be executed - py_c_call.py import sys import os from ctypes import CDLL from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"py-c-so-example\" ) \\ . getOrCreate () basedir = os . path . abspath ( os . path . dirname ( __file__ )) libpath = os . path . join ( basedir , 'libexample.so' ) sum_list = CDLL ( libpath ) data = [( 1 , 2 ),( 2 , 3 ),( 5 , 6 )] columns = [ \"a\" , \"b\" ] df = spark . sparkContext . parallelize ( data ) . toDF ( columns ) df . withColumn ( 'total' , sum_list . add ( df . a , df . b )) . collect () spark . stop () Request: cat > spark-python-in-s3-Clib.json <<EOF { \"name\": \"spark-python-in-s3-Clib\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py_c_call.py\", \"sparkSubmitParameters\": \"--files s3://<s3 prefix>/libexample.so --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-Clib.json Configuration of interest: --files s3://<s3 prefix>/libexample.so distributes the libexample.so to the working directory of all executors. Dynamic modules(.pyd, .so) can also be imported by bundling within .egg ( SPARK-6764 ), .whl and .pex files.","title":"Pyspark"},{"location":"submit-applications/docs/spark/pyspark/#pyspark-job-submission","text":"Python interpreter is bundled in the EMR containers spark image that is used to run the spark job.Python code and dependencies can be provided with the below options.","title":"Pyspark Job submission"},{"location":"submit-applications/docs/spark/pyspark/#python-code-self-contained-in-a-single-py-file","text":"To start with, in the most simplest scenario - the example below shows how to submit a pi.py file that is self contained and doesn't need any other dependencies.","title":"Python code self contained in a single .py file"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-s3","text":"Request pi.py used in the below request payload is from spark examples cat > spark-python-in-s3.json << EOF { \"name\": \"spark-python-in-image\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/pi.py\", \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///Spark-Python-in-s3.json","title":"Python file from S3"},{"location":"submit-applications/docs/spark/pyspark/#python-file-from-mounted-volume","text":"In the below example - pi.py is placed in a mounted volume. FSx for Lustre filesystem is mounted as a Persistent Volume on the driver pod under /var/data/ and will be referenced by local:// file prefix. For more information on how to mount FSx for lustre - EMR-Containers-integration-with-FSx-for-Lustre This approach can be used to provide spark application code and dependencies for execution. Persistent Volume mounted to the driver and executor pods lets you access the application code and dependencies with local:// prefix. cat > spark - python - in - FSx . json << EOF { \"name\" : \"spark-python-in-FSx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"local:///var/data/FSxLustre-pi.py\" , \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } EOF aws emr - containers start - job - run -- cli - input - json file : /// Spark - Python - in - Fsx . json","title":"Python file from mounted volume"},{"location":"submit-applications/docs/spark/pyspark/#python-code-with-dependencies","text":"","title":"Python code with dependencies"},{"location":"submit-applications/docs/spark/pyspark/#list-of-py-files","text":"This is not a scalable approach as the number of dependent files can grow to a large number, and also need to manually specify all of the transitive dependencies. cat > py - files - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext import dependentFunc if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF cat > dependentFunc.py <<EOF def message(): print(\"Printing from inside the dependent python file\") EOF Upload dependentFunc.py and py-files-pi.py to s3 Request: cat > spark-python-in-s3-dependency-files << EOF { \"name\": \"spark-python-in-s3-dependency-files\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/dependentFunc.py --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-files.json","title":"List of .py files"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-zip-file","text":"In this approach all the dependent python files are bundled as a zip file. Each folder should have __init__.py file as documented in zip python dependencies . Zip should be done at the top folder level and using the -r option. zip -r pyspark-packaged-dependency-src.zip . adding: dependent/ (stored 0%) adding: dependent/__init__.py (stored 0%) adding: dependent/dependentFunc.py (deflated 7%) dependentFunc.py from earlier example has been bundled as pyspark-packaged-dependency-src.zip . Upload this file to a S3 location cat > py - files - zip - pi . py << EOF from __future__ import print_function import sys from random import random from operator import add from pyspark.sql import SparkSession from pyspark import SparkContext ** from dependent import dependentFunc ** if __name__ == \"__main__\" : \"\"\" Usage: pi [partitions] \"\"\" spark = SparkSession . builder . getOrCreate () sc = spark . sparkContext partitions = int ( sys . argv [ 1 ]) if len ( sys . argv ) > 1 else 2 n = 100000 * partitions def f ( _ ): x = random () * 2 - 1 y = random () * 2 - 1 return 1 if x ** 2 + y ** 2 <= 1 else 0 count = spark . sparkContext . parallelize ( range ( 1 , n + 1 ), partitions ) . map ( f ) . reduce ( add ) dependentFunc . message () print ( \"Pi is roughly %f \" % ( 4.0 * count / n )) spark . stop () EOF Request: cat > spark-python-in-s3-dependency-zip.json <<EOF { \"name\": \"spark-python-in-s3-dependency-zip\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark-packaged-dependency-src.zip --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-zip.json","title":"Bundled as a zip file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-egg-file","text":"Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .egg file cd / pyspark - packaged - example pip install setuptools python setup . py bdist_egg Upload dist/pyspark_packaged_example-0.0.3-py3.8.egg to a S3 location Request: cat > spark-python-in-s3-dependency-egg.json <<EOF { \"name\": \"spark-python-in-s3-dependency-egg\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3.8.egg --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-egg.json","title":"Bundled as a .egg file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-whl-file","text":"Create a folder structure as in the below screenshot with the code from the previous example - py-files-zip-pi.py, dependentFunc.py Steps to create .whl file cd /pyspark-packaged-example `pip install wheel` python setup.py bdist_wheel Upload dist/pyspark_packaged_example-0.0.3-py3-none-any.whl to a s3 location Request: cat > spark-python-in-s3-dependency-wheel.json <<EOF { \"name\": \"spark-python-in-s3-dependency-wheel\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py-files-zip-pi.py\", \"sparkSubmitParameters\": \"--py-files s3://<s3 prefix>/pyspark_packaged_example-0.0.3-py3-none-any.whl --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-dependency-wheel.json","title":"Bundled as a .whl file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-pex-file","text":"pex is a library for generating .pex (Python EXecutable) files which are executable Python environments.PEX files can be created as below docker run -it -v $(pwd):/workdir python:3.7.9-buster /bin/bash #python 3.7.9 is installed in EMR 6.1.0 pip3 install pex pex --python=python3 --inherit-path=prefer -v numpy -o numpy_dep.pex To read more about PEX: PEX PEX documentation Tips on PEX pex packaging for pyspark Approach 1: Using Persistent Volume - FSx for Lustre cluster Upload numpy_dep.pex to a s3 location that is mapped to a FSx for Lustre cluster. numpy_dep.pex can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod. Request: kmeans.py used in the below request is from spark examples cat > spark - python - in - s3 - pex - fsx . json << EOF { \"name\" : \"spark-python-in-s3-pex-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.kubernetes.driverEnv.PEX_ROOT\" : \"./tmp\" , \"spark.executorEnv.PEX_ROOT\" : \"./tmp\" , \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.executorEnv.PEX_INHERIT_PATH\" : \"prefer\" , \"spark.kubernetes.driverEnv.PEX_VERBOSE\" : \"10\" , \"spark.kubernetes.driverEnv.PEX_PYTHON\" : \"python3\" , \"spark.executorEnv.PEX_PYTHON\" : \"python3\" , \"spark.pyspark.driver.python\" : \"/var/data/numpy_dep.pex\" , \"spark.pyspark.python\" : \"/var/data/numpy_dep.pex\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } aws emr - containers start - job - run -- cli - input - json file : //// Spark - Python - in - s3 - pex - fsx . json Approach 2: Using Custom Pod Templates Upload numpy_dep.pex to a s3 location. Create custom pod templates for driver and executor pods. Custom pod templates allows running a command through initContainers before the main application container is created. In this case, the command will download the numpy_dep.pex file to the /tmp/numpy_dep.pex path of the driver and executor pods. Note: This approach is only supported for release image 5.33.0 and later or 6.3.0 and later. Sample driver pod template YAML file: cat > driver_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-driver initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Sample executor pod template YAML file: cat > executor_pod_tenplate.yaml <<EOF apiVersion: v1 kind: Pod spec: containers: - name: spark-kubernetes-executor initContainers: - name: my-init-container image: 895885662937.dkr.ecr.us-west-2.amazonaws.com/spark/emr-5.33.0-20210323:2.4.7-amzn-1-vanilla volumeMounts: - name: temp-data-dir mountPath: /tmp command: - sh - -c - aws s3api get-object --bucket <s3-bucket> --key <s3-key-prefix>/numpy_dep.pex /tmp/numpy_dep.pex && chmod u+x /tmp/numpy_dep.pex EOF Replace initContainer's image with the respective release label's container image. In this case we are using the image of release emr-5.33.0-latest . Upload the driver and executor custom pod templates to S3 Request: kmeans.py used in the below request is from spark examples cat > spark-python-in-s3-pex-pod-templates.json << EOF { \"name\": \"spark-python-in-s3-pex-pod-templates\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-5.33.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/kmeans.py\", \"entryPointArguments\": [ \"s3://<s3 prefix>/kmeans_data.txt\", \"2\", \"3\" ], \"sparkSubmitParameters\": \"--conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.kubernetes.pyspark.pythonVersion\":\"3\", \"spark.kubernetes.driverEnv.PEX_ROOT\":\"./tmp\", \"spark.executorEnv.PEX_ROOT\":\"./tmp\", \"spark.kubernetes.driverEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.executorEnv.PEX_INHERIT_PATH\":\"prefer\", \"spark.kubernetes.driverEnv.PEX_VERBOSE\":\"10\", \"spark.kubernetes.driverEnv.PEX_PYTHON\":\"python3\", \"spark.executorEnv.PEX_PYTHON\":\"python3\", \"spark.pyspark.driver.python\":\"/tmp/numpy_dep.pex\", \"spark.pyspark.python\":\"/tmp/numpy_dep.pex\", \"spark.kubernetes.driver.podTemplateFile\": \"s3://<s3-prefix>/driver_pod_template.yaml\", \"spark.kubernetes.executor.podTemplateFile\": \"s3://<s3-prefix>/executor_pod_template.yaml\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } aws emr-containers start-job-run --cli-input-json file:////Spark-Python-in-s3-pex-pod-templates.json Point to Note: PEX files don\u2019t have the python interpreter bundled with it. Using the PEX env variables, we pass in the python interpreter installed in the spark driver and executor docker image. pex vs conda-pack A pex file contain only dependent Python packages but not a Python interpreter in it while a conda-pack environment has a Python interpreter as well, so with the same Python packages a conda-pack environment is much larger than a pex file. A conda-pack environment is a tar.gz file and need to be decompressed before being used while a pex file can be used directly. If a Python interpreter exists, pex is a better option than conda-pack. However, conda-pack is the ONLY CHOICE if you need a specific version of Python interpreter which does not exist and you do not have permission to install one (e.g., when you need to use a specific version of Python interpreter with an enterprise PySpark cluster). If the pex file or conda-pack environment needs to be distributed to machines on demand, there are some overhead before running your application. With the same Python packages, a conda-pack environment has large overhead/latency than the pex file as the conda-pack environment is usually much larger and need to be decompressed before being used. For more information - Tips on PEX","title":"Bundled as a .pex file"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-a-targz-file-with-conda-pack","text":"conda-pack for spark Install conda through Miniconda Open a new terminal and execute the below commands conda create -y -n example python=3.5 numpy conda activate example pip install conda-pack conda pack -f -o numpy_environment.tar.gz Upload numpy_environment.tar.gz to a s3 location that is mapped to a FSx for Lustre cluster. numpy_environment.tar.gz can be placed on any Kubernetes persistent volume and mounted to the driver pod and executor pod.Alternatively, S3 path for numpy_environment.tar.gz can also be passed using --py-files Request: { \"name\" : \"spark-python-in-s3-conda-fsx\" , \"virtualClusterId\" : \"<virtual-cluster-id>\" , \"executionRoleArn\" : \"<execution-role-arn>\" , \"releaseLabel\" : \"emr-6.2.0-latest\" , \"jobDriver\" : { \"sparkSubmitJobDriver\" : { \"entryPoint\" : \"s3://<s3 prefix>/kmeans.py\" , \"entryPointArguments\" : [ \"s3://<s3 prefix>/kmeans_data.txt\" , \"2\" , \"3\" ], \"sparkSubmitParameters\" : \"--verbose --archives /var/data/numpy_environment.tar.gz#environment --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=4\" } }, \"configurationOverrides\" : { \"applicationConfiguration\" : [ { \"classification\" : \"spark-defaults\" , \"properties\" : { \"spark.executor.instances\" : \"3\" , \"spark.dynamicAllocation.enabled\" : \"false\" , \"spark.files\" : \"/var/data/numpy_environment.tar.gz#environment\" , \"spark.kubernetes.pyspark.pythonVersion\" : \"3\" , \"spark.pyspark.driver.python\" : \"./environment/bin/python\" , \"spark.pyspark.python\" : \"./environment/bin/python\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.driver.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.options.claimName\" : \"fsx-claim\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.path\" : \"/var/data/\" , \"spark.kubernetes.executor.volumes.persistentVolumeClaim.sparkdata.mount.readOnly\" : \"false\" } } ], \"monitoringConfiguration\" : { \"cloudWatchMonitoringConfiguration\" : { \"logGroupName\" : \"/emr-containers/jobs\" , \"logStreamNamePrefix\" : \"demo\" }, \"s3MonitoringConfiguration\" : { \"logUri\" : \"s3://joblogs\" } } } } The above request doesn't work with spark on kubernetes","title":"Bundled as a tar.gz file with conda-pack"},{"location":"submit-applications/docs/spark/pyspark/#bundled-as-virtual-env","text":"This will not work with spark on kubernetes .This feature only works with YARN - cluster mode In this implementation for YARN - the dependencies will be installed from the repository for every driver and executor. This might not be a more scalable model as per SPARK-25433 . Recommended solution is to pass in the dependencies as PEX file.","title":"Bundled as virtual env"},{"location":"submit-applications/docs/spark/pyspark/#import-of-dynamic-modules-pyd-so","text":"Import of dynamic modules(.pyd, .so) is disallowed when bundled as a zip Steps to create a .so file example.c /* File : example.c */ #include \"example.h\" unsigned int add ( unsigned int a , unsigned int b ) { printf ( \" \\n Inside add function in C library \\n \" ); return ( a + b ); } example.h /* File : example.h */ # include < stdio . h > extern unsigned int add ( unsigned int a , unsigned int b ) ; gcc -fPIC -Wall -g -c example.c gcc -shared -fPIC -o libexample.so example.o Upload libexample.so to a S3 location. pyspark code to be executed - py_c_call.py import sys import os from ctypes import CDLL from pyspark.sql import SparkSession if __name__ == \"__main__\" : spark = SparkSession \\ . builder \\ . appName ( \"py-c-so-example\" ) \\ . getOrCreate () basedir = os . path . abspath ( os . path . dirname ( __file__ )) libpath = os . path . join ( basedir , 'libexample.so' ) sum_list = CDLL ( libpath ) data = [( 1 , 2 ),( 2 , 3 ),( 5 , 6 )] columns = [ \"a\" , \"b\" ] df = spark . sparkContext . parallelize ( data ) . toDF ( columns ) df . withColumn ( 'total' , sum_list . add ( df . a , df . b )) . collect () spark . stop () Request: cat > spark-python-in-s3-Clib.json <<EOF { \"name\": \"spark-python-in-s3-Clib\", \"virtualClusterId\": \"<virtual-cluster-id>\", \"executionRoleArn\": \"<execution-role-arn>\", \"releaseLabel\": \"emr-6.2.0-latest\", \"jobDriver\": { \"sparkSubmitJobDriver\": { \"entryPoint\": \"s3://<s3 prefix>/py_c_call.py\", \"sparkSubmitParameters\": \"--files s3://<s3 prefix>/libexample.so --conf spark.executor.instances=2 --conf spark.executor.memory=2G --conf spark.driver.memory=2G --conf spark.executor.cores=2\" } }, \"configurationOverrides\": { \"applicationConfiguration\": [ { \"classification\": \"spark-defaults\", \"properties\": { \"spark.dynamicAllocation.enabled\":\"false\" } } ], \"monitoringConfiguration\": { \"cloudWatchMonitoringConfiguration\": { \"logGroupName\": \"/emr-containers/jobs\", \"logStreamNamePrefix\": \"demo\" }, \"s3MonitoringConfiguration\": { \"logUri\": \"s3://joblogs\" } } } } EOF aws emr-containers start-job-run --cli-input-json file:///spark-python-in-s3-Clib.json Configuration of interest: --files s3://<s3 prefix>/libexample.so distributes the libexample.so to the working directory of all executors. Dynamic modules(.pyd, .so) can also be imported by bundling within .egg ( SPARK-6764 ), .whl and .pex files.","title":"Import of Dynamic Modules (.pyd, .so)"},{"location":"submit-applications/docs/spark/sparkr/","text":"","title":"Sparkr"},{"location":"submit-applications/docs/spark/sparksql/","text":"","title":"Sparksql"}]}